<!DOCTYPE html>

















































<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <meta name="description" content="Javadoc API documentation for Insiteo API Documentation - Version 3.2.0." />

<link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.ico" />
<title>

  ItineraryProvider.ItineraryRequest


| Insiteo API Documentation - Version 3.2.0

</title>
<link href="../../../../../assets/doclava-developer-docs.css" rel="stylesheet" type="text/css" />
<link href="../../../../../assets/customizations.css" rel="stylesheet" type="text/css" />
<script src="../../../../../assets/search_autocomplete.js" type="text/javascript"></script>
<script src="../../../../../assets/jquery-resizable.min.js" type="text/javascript"></script>
<script src="../../../../../assets/doclava-developer-docs.js" type="text/javascript"></script>
<script src="../../../../../assets/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  setToRoot("../../../../", "../../../../../assets/");
</script>
<script src="../../../../../assets/doclava-developer-reference.js" type="text/javascript"></script>
<script src="../../../../../assets/navtree_data.js" type="text/javascript"></script>
<script src="../../../../../assets/customizations.js" type="text/javascript"></script>
<noscript>
  <style type="text/css">
    html,body{overflow:auto;}
    #body-content{position:relative; top:0;}
    #doc-content{overflow:visible;border-left:3px solid #666;}
    #side-nav{padding:0;}
    #side-nav .toggle-list ul {display:block;}
    #resize-packages-nav{border-bottom:3px solid #666;}
  </style>
</noscript>
</head>

<body class="">

<div id="header">
    <div id="headerLeft">
    
      <span id="masthead-title">Insiteo API Documentation - Version 3.2.0</span>
    
    </div>
    <div id="headerRight">
      
  <div id="search" >
      <div id="searchForm">
          <form accept-charset="utf-8" class="gsc-search-box" 
                onsubmit="return submit_search()">
            <table class="gsc-search-box" cellpadding="0" cellspacing="0"><tbody>
                <tr>
                  <td class="gsc-input">
                    <input id="search_autocomplete" class="gsc-input" type="text" size="33" autocomplete="off"
                      title="search developer docs" name="q"
                      value="search developer docs"
                      onFocus="search_focus_changed(this, true)"
                      onBlur="search_focus_changed(this, false)"
                      onkeydown="return search_changed(event, true, '../../../../')"
                      onkeyup="return search_changed(event, false, '../../../../')" />
                  <div id="search_filtered_div" class="no-display">
                      <table id="search_filtered" cellspacing=0>
                      </table>
                  </div>
                  </td>
                  <td class="gsc-search-button">
                    <input type="submit" value="Search" title="search" id="search-button" class="gsc-search-button" />
                  </td>
                  <td class="gsc-clear-button">
                    <div title="clear results" class="gsc-clear-button">&nbsp;</div>
                  </td>
                </tr></tbody>
              </table>
          </form>
      </div><!-- searchForm -->
  </div><!-- search -->
      
    </div>
</div><!-- header -->


  <div class="g-section g-tpl-240" id="body-content">
    <div class="g-unit g-first side-nav-resizable" id="side-nav">
      <div id="swapper">
        <div id="nav-panels">
          <div id="resize-packages-nav">
            <div id="packages-nav">
              <div id="index-links">
                <a href="../../../../packages.html"  >Package Index</a> | 
                <a href="../../../../classes.html" >Class Index</a>
              </div>
              <ul>
                
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/analytics/package-summary.html">com.insiteo.lbs.analytics</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/analytics/entities/package-summary.html">com.insiteo.lbs.analytics.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/common/package-summary.html">com.insiteo.lbs.common</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/common/auth/package-summary.html">com.insiteo.lbs.common.auth</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/common/auth/entities/package-summary.html">com.insiteo.lbs.common.auth.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/common/init/package-summary.html">com.insiteo.lbs.common.init</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/geofence/package-summary.html">com.insiteo.lbs.geofence</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/geofence/render/package-summary.html">com.insiteo.lbs.geofence.render</a></li>
    <li class="selected api apilevel-">
  <a href="../../../../com/insiteo/lbs/itinerary/package-summary.html">com.insiteo.lbs.itinerary</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/itinerary/entities/package-summary.html">com.insiteo.lbs.itinerary.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/location/package-summary.html">com.insiteo.lbs.location</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/location/utils/package-summary.html">com.insiteo.lbs.location.utils</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/map/package-summary.html">com.insiteo.lbs.map</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/map/database/package-summary.html">com.insiteo.lbs.map.database</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/map/entities/package-summary.html">com.insiteo.lbs.map.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/map/gestures/package-summary.html">com.insiteo.lbs.map.gestures</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/map/render/package-summary.html">com.insiteo.lbs.map.render</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/map/utils/package-summary.html">com.insiteo.lbs.map.utils</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/meetme/package-summary.html">com.insiteo.lbs.meetme</a></li>
    <li class="api apilevel-">
  <a href="../../../../com/insiteo/lbs/meetme/requests/package-summary.html">com.insiteo.lbs.meetme.requests</a></li>
              </ul><br/>
            </div> <!-- end packages -->
          </div> <!-- end resize-packages -->
          <div id="classes-nav">
            <ul>
              
    <li><h2>Interfaces</h2>
      <ul>
          <li class="api apilevel-"><a href="../../../../com/insiteo/lbs/itinerary/IItineraryRendererListener.html">IItineraryRendererListener</a></li>
          <li class="api apilevel-"><a href="../../../../com/insiteo/lbs/itinerary/IItineraryRequestListener.html">IItineraryRequestListener</a></li>
      </ul>
    </li>
              
    <li><h2>Classes</h2>
      <ul>
          <li class="api apilevel-"><a href="../../../../com/insiteo/lbs/itinerary/ItineraryError.html">ItineraryError</a></li>
          <li class="api apilevel-"><a href="../../../../com/insiteo/lbs/itinerary/ItineraryProvider.html">ItineraryProvider</a></li>
          <li class="api apilevel-"><a href="../../../../com/insiteo/lbs/itinerary/ItineraryProvider.BaseRequest.html">ItineraryProvider.BaseRequest</a></li>
          <li class="selected api apilevel-"><a href="../../../../com/insiteo/lbs/itinerary/ItineraryProvider.ItineraryRequest.html">ItineraryProvider.ItineraryRequest</a></li>
          <li class="api apilevel-"><a href="../../../../com/insiteo/lbs/itinerary/ItineraryProvider.OptimizeRequest.html">ItineraryProvider.OptimizeRequest</a></li>
          <li class="api apilevel-"><a href="../../../../com/insiteo/lbs/itinerary/ItineraryRenderer.html">ItineraryRenderer</a></li>
      </ul>
    </li>
              
              
    <li><h2>Enums</h2>
      <ul>
          <li class="api apilevel-"><a href="../../../../com/insiteo/lbs/itinerary/ItineraryProvider.EOptimizationMode.html">ItineraryProvider.EOptimizationMode</a></li>
      </ul>
    </li>
              
              
            </ul><br/>
          </div><!-- end classes -->
        </div><!-- end nav-panels -->
        <div id="nav-tree" style="display:none">
          <div id="index-links">
            <a href="../../../../packages.html"  >Package Index</a> | 
            <a href="../../../../classes.html" >Class Index</a>
          </div>
        </div><!-- end nav-tree -->
      </div><!-- end swapper -->
    </div> <!-- end side-nav -->
    <script>
      if (!isMobile) {
        $("<a href='#' id='nav-swap' onclick='swapNav();return false;' style='font-size:10px;line-height:9px;margin-left:1em;text-decoration:none;'><span id='tree-link'>Use Tree Navigation</span><span id='panel-link' style='display:none'>Use Panel Navigation</span></a>").appendTo("#side-nav");
        chooseDefaultNav();
        if ($("#nav-tree").is(':visible')) {
          init_default_navtree("../../../../");
        } else {
          addLoadEvent(function() {
            scrollIntoView("packages-nav");
            scrollIntoView("classes-nav");
          });
        }
        $("#swapper").css({borderBottom:"2px solid #aaa"});
      } else {
        swapNav(); // tree view should be used on mobile
      }
    </script>



<div class="g-unit" id="doc-content">

<div id="api-info-block">



  
   
  
  
  
  

  
   
  
  
  
  


<div class="sum-details-links">

<div>
<a href="ItineraryProvider.ItineraryRequest.html">View Documentation</a>
</div>


</div><!-- end sum-details-links -->
<div class="api-level">
  


  
  

</div>
</div><!-- end api-info-block -->


<!-- ======== START OF CLASS DATA ======== -->

<div id="jd-header">
    public
     
     
    
    class
<h1>ItineraryProvider.ItineraryRequest</h1>



  
  
  

  
    extends <a href="../../../../com/insiteo/lbs/itinerary/ItineraryProvider.BaseRequest.html">ItineraryProvider.BaseRequest</a><br/>
  
  
  

  
  
  


</div><!-- end header -->
<div id="jd-content">
  <pre class="prettyprint">
package com.insiteo.lbs.itinerary;

import java.util.ArrayList;
import java.util.concurrent.Semaphore;

import android.content.res.Resources;
import android.graphics.PointF;
import android.graphics.RectF;
import android.os.SystemClock;
import android.util.Pair;

import com.insiteo.lbs.analytics.AnalyticsConstants;
import com.insiteo.lbs.analytics.AnalyticsManager;
import com.insiteo.lbs.analytics.entities.AnalyticsGenericEvent;
import com.insiteo.lbs.common.CommonConstants;
import com.insiteo.lbs.common.InsiteoError;
import com.insiteo.lbs.common.init.EPackageType;
import com.insiteo.lbs.common.init.InitProvider;
import com.insiteo.lbs.common.utils.Log;
import com.insiteo.lbs.common.utils.geometry.Position;
import com.insiteo.lbs.itinerary.embedded.EmbeddedItineraryManager;
import com.insiteo.lbs.itinerary.entities.Instruction;
import com.insiteo.lbs.itinerary.entities.Itinerary;
import com.insiteo.lbs.itinerary.entities.Section;
import com.insiteo.lbs.location.ELocationModule;
import com.insiteo.lbs.location.ILbsModule;
import com.insiteo.lbs.location.InsLocation;
import com.insiteo.lbs.location.LocationConstants;
import com.insiteo.lbs.location.LocationProvider;
import com.insiteo.lbs.location.parser.LbsModuleRequest;
import com.insiteo.lbs.location.parser.LbsModuleResponse;


/**
 * Class that is the entry point for itinerary requests. 
 * You can retrieve an instance of it by calling &lt;code&gt;(ItineraryProvider)LocationProvider.getInstance().getModule(ELocationModule.ITINERARY)&lt;/code&gt;
 * Itinerary computation can be done if ITINERARY package is installed. 
 * When using dynamicMode (default OFF), itinerary will be refreshed each time location changes. 
 */
public class ItineraryProvider implements ILbsModule {

	private final static String TAG = ItineraryProvider.class.getSimpleName();

	private static final int ITINERARY_ID = 1;
	private static final ELocationModule TYPE = ELocationModule.ITINERARY;

	private static int sRequestsCount = 0;	//used to give an ID to the requests
	private ItineraryRenderer mRenderer = null;
	private GfxItinerary mItinerary = null;
	private ItineraryRequest mLastRequest = null;
	private InsLocation mLastLocation = null;
	private int mLastLocationCount = 0;	//incremental counter, updated each time a new location is set 

	private Semaphore mItineraryMutex = new Semaphore(1);
	private EmbeddedItineraryManager mEmbeddedManager = null;
	private volatile boolean mDynamicMode = false;


	/**
	 * Default constructor. Use this if you need stand alone itinerary.
	 * If you need to bind itinerary with location, use {@link LocationProvider#getModule(ELocationModule) LocationProvider.getModule} with type ITINERARY. 
	 */
	public ItineraryProvider() {
	}

	/**
	 * Activate/desactivate dynamic mode.
	 * When dynamic mode is ON, itinerary will be refreshed each time location is updated.
	 * Dynamic mode must be set to true to received {@link IItineraryRequestListener#onItineraryChanged(BaseRequest, float)} callback.
	 * @param isDynamic true to switch ON dynamic mode,  false to switch it of.
	 */
	public void setDynamicMode(boolean isDynamic) {
		mDynamicMode = isDynamic;
	}

	/**
	 * Get the IRenderer for the itinerary
	 * @param aResources resources used to build renderer.
	 * @return the IRenderer for itinerary
	 */
	public ItineraryRenderer getRenderer(Resources aResources) {
		if (mRenderer == null) {
			mItinerary = new GfxItinerary(ITINERARY_ID, this);
			mRenderer = new ItineraryRenderer(aResources);
		}
		return mRenderer;
	}

	/**
	 * Request route from current location to destination. 
	 * Be careful to start LocationProvider before calling this, otherwise itinerary will fail.
	 * @param destination the destination of the itinerary
	 * @param useLastLoc if true, the itinerary will be calculated from last known location, without waiting for location refresh
	 * @param listener the listener that will receive notifications for this request
	 * @param disabled if true, itinerary will be calculated for persons with limited mobility
	 * @return the request that will be filled with the itinerary
	 */
	public ItineraryRequest requestItineraryFromCurrentLocation(Position destination, boolean useLastLoc, IItineraryRequestListener listener, boolean disabled) { 
		ItineraryRequest request;
		Position departure = null;
		if (useLastLoc &amp;&amp; mLastLocation != null) {
			departure = new Position(mLastLocation.getMapID(), (float) mLastLocation.getCoord().x, (float) mLastLocation.getCoord().y);
		}
		request = requestItinerary(departure, destination, listener, disabled);

		if(request != null) request.setIsFromLocation(true); 
		
		return request;
	}

	/**
	 * Request route from given departure to your current location 
	 * Be careful to start LocationProvider before calling this, otherwise itinerary will fail.
	 * @param departure the departure of the itinerary
	 * @param useLastLoc if true, the itinerary will be calculated to last known location, without waiting for location refresh
	 * @param listener the listener that will receive notifications for this request
	 * @param disabled if true, itinerary will be calculated for persons with limited mobility
	 * @return the request that will be filled with the itinerary
	 */
	public ItineraryRequest requestItineraryToCurrentLocation(Position departure, boolean useLastLoc, IItineraryRequestListener listener, boolean disabled) { 
		ItineraryRequest request;
		Position destination = null;
		if (useLastLoc &amp;&amp; mLastLocation != null) {
			destination = new Position(mLastLocation.getMapID(), (float) mLastLocation.getCoord().x, (float) mLastLocation.getCoord().y);
		}
		request = requestItinerary(departure, destination, listener, disabled);

		if(request != null) request.setIsToLocation(true); 
		
		return request;
	}

	/**
	 * Request route from departure to destination. 
	 * @param departure the departure of the itinerary.
	 * @param destination the destination of the itinerary
	 * @param listener the listener that will receive notifications for this request
	 * @param disabled if true, itinerary will be calculated for persons with limited mobility
	 * @return the request that will be filled with the itinerary
	 */
	public ItineraryRequest requestItinerary(Position departure, Position destination, IItineraryRequestListener listener, boolean disabled) { 
		ItineraryRequest request = new ItineraryRequest(departure, destination, listener, disabled);
		request.loadRoute();

		AnalyticsGenericEvent itineraryEvent = new AnalyticsGenericEvent(AnalyticsConstants.IS_ITI_LABEL);
		itineraryEvent.setInt1((disabled) ? 1 : 0);
		itineraryEvent.setPos1(request.mDeparture);
		itineraryEvent.setPos2(request.mDestination);
		AnalyticsManager.getInstance().addGenericEvent(itineraryEvent);
		return request;
	}	

	/**
	 * Request shortest route from departures to destinations.
	 * Only one departure and one destination will be selected after computation (those defining the shortest path).
	 * Selected departure and destination can be retreived by calling getDestination() and getDeparture() on the returned request, after the route is calculated.   
	 * @param departures the list of potential departures of the itinerary.
	 * @param destinations the list of potential destinations of the itinerary
	 * @param listener the listener that will receive notifications for this request
	 * @param disabled if true, itinerary will be calculated for persons with limited mobility
	 * @return the request that will be filled with the itinerary
	 */
	public ItineraryRequest requestItinerary(ArrayList&lt;Position&gt; departures, ArrayList&lt;Position&gt; destinations, IItineraryRequestListener listener, boolean disabled) { 
		ItineraryRequest request = new ItineraryRequest(departures, destinations, listener, disabled);
		request.loadRoute();

		AnalyticsGenericEvent itineraryEvent = new AnalyticsGenericEvent(AnalyticsConstants.IS_ITI_LABEL);
		itineraryEvent.setInt1((disabled) ? 1 : 0);
		itineraryEvent.setPos1(request.mDeparture);
		itineraryEvent.setPos2(request.mDestination);
		AnalyticsManager.getInstance().addGenericEvent(itineraryEvent);

		return request;
	}	

	/**
	 * Request a route optimization : the given route will be re-ordered to be as short as possible.
	 * @param waypoints the route to optimize
	 * @param keepFirstPosition if true, first point of route will stay first once optimized
	 * @param keepLastPosition if true, last point of route will stay last once optimized
	 * @param listener a listener that will receive notifications once the route is optimized
	 * @param pmr if true, route will be optimized for persons with limited mobility
	 * @return the request that will be filled with the optimized route
	 */
	public OptimizeRequest requestOptimizedItinerary(final ArrayList&lt;Position&gt; waypoints, EOptimizationMode mode, boolean keepFirstPosition, boolean keepLastPosition, IItineraryRequestListener listener, boolean pmr) {
		OptimizeRequest request = new OptimizeRequest(waypoints, mode, keepFirstPosition, keepLastPosition, listener, pmr);
		request.loadRoute();
		return request;
	}


	PointF getInstructionIndex(int mapId, double x, double y) {
		Log.d(TAG, "call to getInstructionIndex : " + mapId + ", x = " + x + ", y = " + y);
		PointF result = new PointF(CommonConstants.NULL_ID, 0);
		if (mEmbeddedManager != null) {
			result = mEmbeddedManager.getInstructionIndex(mapId, x, y);
		}

		Log.d(TAG, "Embedded instruction index : " + ((result != null) ? (result.x + ", " + result.y) : result + ""));

		return result;
	}

	
	/**
	 * Returns the last {@link ItineraryRequest} that was triggered.
	 * @return
	 */
	public ItineraryRequest getLastItineraryRequest() {
		return mLastRequest;
	}

	// ==================================================================================================
	// LbsModule
	// ==================================================================================================

	@Override
	public ELocationModule getType() {
		return TYPE;
	}

	/**
	 * @hide
	 */
	@Override
	public boolean addLbsModuleRequest(LbsModuleRequest aLocRequest) {
		return false;
	}

	/**
	 * @hide
	 */
	@Override
	public void setLbsResponse(LbsModuleResponse aLocResponse) {
	}

	/**
	 * @hide
	 */
	@Override
	public void setLocation(InsLocation aLocation) {
		//save location. If location is null, keep last known location
		if (aLocation != null) {
			Log.d(TAG, "Location : " + aLocation.getPosition().toString());
			mLastLocation = aLocation;

			//update itinerary if dynamic mode is active
			if (mDynamicMode &amp;&amp; mLastRequest != null) {
				boolean isLocked = mItineraryMutex.tryAcquire();
				if (isLocked) {
					if(mEmbeddedManager != null) {
						Pair&lt;Float, Boolean&gt; res = mEmbeddedManager.setCurrentLocation(aLocation.getPosition());
						mLastRequest.updateRoute(res.first);
					}
					mItineraryMutex.release();
				}
			}

			mLastLocationCount++;
		}
	}

	@Override
	/**
	 * @hide
	 */
	public void clear() {
		mEmbeddedManager = null;
	}

	//===========================================================
	// OptimizeRequest 
	//===========================================================


	/**
	 * Optimization mode that will be used to compute the optimized itinerary
	 *
	 */
	public enum EOptimizationMode{
		EOptimizationModeFullRoute(1),
		EOptimizationModeEuclidianDistance(2),
		//EOptimizationModeQuadAreas(3),
		EOptimizationModeNearestNeighbourEuclidian(4),
		EOptimizationModeNearestNeighbourShortestPath(5),
		//EOptimizationModeHybridPath(6),
		EOptimizationModeBestMethodPath(7);

		private int mValue;

		private EOptimizationMode(int value) {
			mValue = value;
		}

		public int getValue() {
			return mValue;
		}
	}

	/**
	 * Inner class that handle a route optimization request, and notify the associated listener.
	 * Optimized route can be retrieved using getOptimizedRouteWaypoints().
	 */
	public class OptimizeRequest extends BaseRequest{

		private EOptimizationMode mOptimMode;

		private boolean mKeepFirstPosition;
		private boolean mKeepLastPosition;

		private ArrayList&lt;Position&gt; mOriginalRoute = null;

		private Position[] mSortedWaypoints = null;
		private int[] mSortedWaypointsIndexes = null;
		private Position[] mCompleteGeometryWaypoints = null;

		/**
		 * Constructor
		 * @param waypoints the route to optimize
		 * @param keepFirstPosition if true, first point of route will stay first once optimized
		 * @param keepLastPosition if true, last point of route will stay last once optimized
		 * @param listener a listener that will receive notifications once the route is optimized
		 * @param pmr if true, route will be optimized for persons with limited mobility
		 */
		public OptimizeRequest(final ArrayList&lt;Position&gt; waypoints, EOptimizationMode mode, boolean keepFirstPosition, boolean keepLastPosition, IItineraryRequestListener listener, boolean pmr) {
			super(CommonConstants.NULL_ID, listener, pmr);
			mOriginalRoute = waypoints;
			mOptimMode = mode;
			mKeepFirstPosition = keepFirstPosition;
			mKeepLastPosition = keepLastPosition;
		}

		/**
		 * Can only be called by the {@link ItineraryProvider}
		 */
		private void loadRoute() {
			if(!InitProvider.getInstance().hasPackage(EPackageType.ITINERARY)) {
				notifyRequestDone(false, new InsiteoError(InsiteoError.NO_ITINERARY_PACKAGE, ""));
			} else {
				new Thread(new Runnable() {
					@Override public void run() {
						try {
							mItineraryMutex.acquire();

							InsiteoError error = compute();

							//check if request was successful, and notify listener
							if(InsiteoError.NO_ERROR_CODE.equals(error.getCode())) {

								if (mRenderer != null &amp;&amp; mItinerary != null) mRenderer.removeRTO(mItinerary);							
								mItinerary.setItinerary(getRoute());
								if (mRenderer != null &amp;&amp; mItinerary != null) mRenderer.addRTO(mItinerary);	

								notifyRequestDone(true, error);
							} else {
								notifyRequestDone(false, error);
							}
						} catch (InterruptedException e) {
							e.printStackTrace();
						} finally {
							mItineraryMutex.release();
						}
					}
				}).start();
			}
		}

		/**
		 * 
		 * @return
		 */
		private InsiteoError compute() {
			InsiteoError error = new InsiteoError(InsiteoError.NO_ERROR_CODE, "");
			//check embedded module status
			if (mEmbeddedManager == null) {
				//create embedded manager and initialize it
				mEmbeddedManager = new EmbeddedItineraryManager();
				mEmbeddedManager.init(isPmr());
			}

			//check PMR mode and reset it if needed
			if (mEmbeddedManager != null &amp;&amp; (mEmbeddedManager.isPMRActivated() != isPmr())) {
				mEmbeddedManager.init(isPmr());
			}

			//check init status before loading route
			if (mEmbeddedManager != null &amp;&amp; mEmbeddedManager.isInitialized()) {
				//ask embedded lib for optimization

				ArrayList&lt;Object&gt; optimizedRoute = null;
				try{
					optimizedRoute = (ArrayList&lt;Object&gt;) mEmbeddedManager.optimizeRoute(mOriginalRoute, mOptimMode, mKeepFirstPosition, mKeepLastPosition);
				} catch(ClassCastException cce){
					Log.d(TAG, "Result from OptimizedRoute could not be cast");
				}


				if (optimizedRoute != null) {
					mSortedWaypoints = (optimizedRoute.size() &gt; 0) ?  (Position[]) optimizedRoute.get(0) : null;
					mSortedWaypointsIndexes = (optimizedRoute.size() &gt; 1) ?  (int[]) optimizedRoute.get(1) : null;
					mCompleteGeometryWaypoints = (optimizedRoute.size() &gt; 2) ?  (Position[]) optimizedRoute.get(2) : null;

					setRoute(createItinerary());

				} else {
					error = new InsiteoError(InsiteoError.EMBEDDED_OPTIM_ERROR_CODE, "");
				}
			} else {
				//could not init iti embedded
				mEmbeddedManager = null;
				error = new InsiteoError(InsiteoError.EMBEDDED_INIT_ERROR_CODE, "");
			}
			return error;
		}


		@Override
		public void recompute() {
			loadRoute();
		}

		private Itinerary createItinerary(){
			Itinerary iti = null;
			if (mCompleteGeometryWaypoints != null) {
				Section[] sections = new Section[mCompleteGeometryWaypoints.length];

				for (int i = 0; i &lt; mCompleteGeometryWaypoints.length; i++) {
					Section section = new Section("", mCompleteGeometryWaypoints[i].getMapID(), mCompleteGeometryWaypoints[i].getX(), mCompleteGeometryWaypoints[i].getY(), 0, 0);
					sections[i] = section;
				}

				Instruction instruction = new Instruction("", "", 0, 0, 0, 0, null, mCompleteGeometryWaypoints[0].getMapID(), sections, "", "");
				ArrayList&lt;Instruction&gt; instructions = new ArrayList&lt;Instruction&gt;();
				instructions.add(instruction);

				iti = new Itinerary(instructions, 0, 0, mCompleteGeometryWaypoints[0], mCompleteGeometryWaypoints[mCompleteGeometryWaypoints.length-1]);

			}
			return iti;
		}


		/**
		 * Returns a list containing original positions, in optimized order (warning : positions in this list are references to original ones).
		 * @return a new ArrayList containing original positions, in optimized order (warning : positions in this list are references to original ones)
		 */
		public Position[] getSortedWaypoints() {
			return mSortedWaypoints;
		}

		/**
		 * Returns an array containing all the indexes of the Positions from the OptimizedRequest in the correct order.
		 * @return An array containing all the indexes of the Positions from the OptimizedRequest in the correct order.
		 */
		public int[] getSortedWaypointIndexes() {
			return mSortedWaypointsIndexes;
		}

		/**
		 * Returns the original list of position.
		 * @return The original list of position
		 */
		public ArrayList&lt;Position&gt; getWaypoints() {
			return mOriginalRoute;
		}
	}

	//===========================================================
	// ItineraryRequest 
	//===========================================================

	/**
	 * Inner class that handle an itinerary request, and notify the associated listener.
	 * Computed itinerary can be retrieved using getRoute().
	 */
	public class ItineraryRequest extends BaseRequest {

		private int mLastCountAtCreate = 0;

		private boolean mIsToLocation, mIsFromLocation;

		private Position mDestination = null;
		private Position mDeparture = null;
		private ArrayList&lt;Position&gt; mPotentialDestinations = null;
		private ArrayList&lt;Position&gt; mPotentialDepartures = null;


		/**
		 * Constructor
		 * @param departure the departure position
		 * @param destination the arrival position
		 * @param listener a listener that will receive notifications once the itinerary is computed
		 * @param disabled if true, itinerary will be computed for persons with limited mobility
		 */
		public ItineraryRequest(final Position departure, final Position destination, IItineraryRequestListener listener, boolean disabled) {
			super(sRequestsCount++, listener, disabled);

			if (destination != null) {
				mPotentialDestinations = new ArrayList&lt;Position&gt;(1);
				mPotentialDestinations.add(destination);
				mDestination = destination;
			} else {
				mIsToLocation = true;
			}

			if (departure != null) {
				mPotentialDepartures = new ArrayList&lt;Position&gt;(1);
				mPotentialDepartures.add(departure);
				mDeparture = departure;
			} else {
				mIsFromLocation = true;
			}

			mLastCountAtCreate = mLastLocationCount;
		}

		/**
		 * Constructor.
		 * When instantiated with this constructor, the Request will compute shortest itinerary between all given departures and all given destinations 
		 * @param departures the list of potential departure positions
		 * @param destinations the list of potential arrival positions
		 * @param listener a listener that will receive notifications once the itinerary is computed
		 * @param disabled if true, itinerary will be computed for persons with limited mobility
		 */
		public ItineraryRequest(final ArrayList&lt;Position&gt; departures, final ArrayList&lt;Position&gt; destinations, IItineraryRequestListener listener, boolean disabled) {
			super(sRequestsCount++, listener, disabled);

			mPotentialDepartures = new ArrayList&lt;Position&gt;(departures);
			mPotentialDestinations = new ArrayList&lt;Position&gt;(destinations);

			mLastCountAtCreate = mLastLocationCount;
		}

		public void setIsToLocation(boolean toLocation) {
			mIsToLocation = toLocation;
		}
		
		public void setIsFromLocation(boolean fromLocation) {
			mIsFromLocation = fromLocation;
		}
		
		/**
		 * Return the destination {@link Position} of this {@link ItineraryRequest}
		 * @return The request's destination
		 */
		public Position getDestination() {
			return mDestination;
		}

		/**
		 * Return the departure {@link Position} of this {@link ItineraryRequest}
		 * @return The request's departure
		 */
		public Position getDeparture() {
			return mDeparture;
		}

		/**
		 * Get the bounding rect of the itinerary on the given map 
		 * @return the bounding rect (in user's coordinates), or null if it cannot be computed
		 */
		public RectF getBoundingRect(int mapID) {
			if (mEmbeddedManager != null) {
				return mEmbeddedManager.getBoundingRect(mapID);
			}
			return null;
		}

		@Override
		public void recompute() {
			if(mDeparture != null &amp;&amp; mDestination != null) {
				if(mIsFromLocation) {
					mPotentialDepartures = null;
					mDeparture = mLastLocation.getPosition();
				} else if(mIsToLocation) {
					mPotentialDestinations = null;
					mDestination = mLastLocation.getPosition();
				}
				loadRoute();
			}
		}

		//update internal route and notify listener
		private void updateRoute(final float aDistanceToIti) {
			new Thread(new Runnable() {
				@Override public void run() {
					Itinerary iti = mEmbeddedManager.getUpdatedRoute();
					if (iti != null) {

						//update mRoute current data with iti
						getRoute().setRemainingDistance(iti.getRemainingDistance());
						getRoute().setRemainingTime(iti.getRemainingTime());

						if (iti.getInstructions().size() &gt; 0) {
							Instruction firstInstr = iti.getInstructions().get(0);
							String firstInstrId = firstInstr.id;
							String firstStepId = firstInstr.steps.get(0).id;

							//update current instruction index/step		
							int instrIndex = 0;
							int stepIndex = 0;
							boolean found = false;
							for (Instruction instr : getRoute().getInstructions()) {
								if (instr.id.equals(firstInstrId)) {
									for (Section sec : instr.steps) {
										if (sec.id.equals(firstStepId)) {
											found = true;
											break;
										}
										stepIndex++;
									}									
									break;
								}
								instrIndex++;
							}							
							if (found) {
								getRoute().setCurrentInstructionIndex(instrIndex);
								getRoute().setCurrentSectionIndex(stepIndex);
							}

							//update first instruction label
							getRoute().setCurrentInstructionInfo(firstInstr.information);
						}

						if (mItinerary != null) {
							mItinerary.updateItinerary(getRoute());
						}

						if (getListener() != null) {
							getListener().onItineraryChanged(ItineraryRequest.this, aDistanceToIti);
						}

					}
				}
			}).start();			
		}

		/**
		 * Computes the {@link ItineraryRequest} in a background {@link Thread}.
		 */
		private void loadRoute() {
			if(!InitProvider.getInstance().hasPackage(EPackageType.ITINERARY)) {
				notifyRequestDone(false, new InsiteoError(InsiteoError.NO_ITINERARY_PACKAGE, ""));
			} else {
				new Thread(new Runnable() {
					@Override public void run() {

						fillPositions();

						try {
							mItineraryMutex.acquire();

							InsiteoError error;
							if (mPotentialDepartures == null || mPotentialDepartures.isEmpty()) {
								error = new InsiteoError(InsiteoError.NO_DEPARTURE_ERROR_CODE, "");
							} else if (mPotentialDestinations == null || mPotentialDestinations.isEmpty()) {
								error = new InsiteoError(InsiteoError.NO_DESTINATION_ERROR_CODE, "");
							} else {
								error = compute();	
							}

							//check if request was successful, and notify listener
							if (InsiteoError.NO_ERROR_CODE.equals(error.getCode())) {
								mLastRequest = ItineraryRequest.this;		

								//clear the renderer from previous itinerary
								if (mRenderer != null &amp;&amp; mItinerary != null) mRenderer.removeRTO(mItinerary);							
								mItinerary.setItinerary(getRoute());
								if (mRenderer != null &amp;&amp; mItinerary != null) mRenderer.addRTO(mItinerary);	
								

								notifyRequestDone(true, null);
							} else {
								notifyRequestDone(false, error);
							}

						} catch (InterruptedException e) {
							e.printStackTrace();
						} finally {
							mItineraryMutex.release();
						}
					}
				}).start();
			}
		}

		/**
		 * Fill all the position required for this {@link ItineraryRequest} ie wait for the location if necessary.
		 */
		private void fillPositions() {
			//if departure or destination are null, pool the location until itinerary timeout is reached
			long startTime = SystemClock.elapsedRealtime();

			// If only one position is set
			boolean departureIsNull = (mPotentialDepartures == null);
			boolean destinationIsNull = (mPotentialDestinations == null);

			// We process the while loop if and only if only one and only one position is set
			boolean xorPos = (departureIsNull &amp;&amp; !destinationIsNull) || (!departureIsNull &amp;&amp; destinationIsNull);

			while (xorPos &amp;&amp; (SystemClock.elapsedRealtime() - startTime &lt; LocationConstants.ITINERARY_WAITFORLOC_TIMEOUT))  {
				if(mLastLocation != null &amp;&amp; mLastLocationCount &gt; mLastCountAtCreate) {
					if (mPotentialDepartures == null) {
						mDeparture = new Position(mLastLocation.getMapID(), (float)mLastLocation.getCoord().x, (float)mLastLocation.getCoord().y);
						mPotentialDepartures = new ArrayList&lt;Position&gt;(1);
						mPotentialDepartures.add(mDeparture);

						departureIsNull = false;
						xorPos = (departureIsNull &amp;&amp; !destinationIsNull) || (!departureIsNull &amp;&amp; destinationIsNull);
					}
					if (mPotentialDestinations == null) {
						mDestination = new Position(mLastLocation.getMapID(), (float)mLastLocation.getCoord().x, (float)mLastLocation.getCoord().y);
						mPotentialDestinations = new ArrayList&lt;Position&gt;(1);
						mPotentialDestinations.add(mDestination);
						destinationIsNull = false;
						xorPos = (departureIsNull &amp;&amp; !destinationIsNull) || (!departureIsNull &amp;&amp; destinationIsNull);
					}
				} else {
					try {
						Thread.sleep(200);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}

		/**
		 * 
		 * @return
		 */
		private InsiteoError compute() {
			InsiteoError error = new InsiteoError(InsiteoError.NO_ERROR_CODE, "");
			//check embedded iti status
			if (mEmbeddedManager == null) {
				//create embedded iti manager and initialize it
				mEmbeddedManager = new EmbeddedItineraryManager();
				mEmbeddedManager.init(isPmr());
			}

			//check PMR mode and reset it if needed
			if (mEmbeddedManager != null &amp;&amp; (mEmbeddedManager.isPMRActivated() != isPmr())) {
				mEmbeddedManager.init(isPmr());
			}

			//check init status before loading route
			if (mEmbeddedManager != null &amp;&amp; mEmbeddedManager.isInitialized()) {
				//ask embedded lib for itinerary
				Itinerary iti = mEmbeddedManager.getRoute(mPotentialDepartures, mPotentialDestinations);

				if (iti != null) {
					mDeparture = new Position(iti.getDeparture());
					mDestination = new Position(iti.getDestination());
					iti.setID(getID());
					setRoute(iti);    		
				} else {
					int itiError = mEmbeddedManager.getLastError();
					error = new InsiteoError(InsiteoError.EMBEDDED_ITI_ERROR_CODE, String.valueOf(itiError));
				}
			} else {
				//could not init iti embedded
				mEmbeddedManager = null;
				error = new InsiteoError(InsiteoError.EMBEDDED_INIT_ERROR_CODE, "");
			}
			return error;
		}
	}


	//===========================================================
	// BaseRequest 
	//===========================================================

	/**
	 * Inner class that handle itinerary request, use the getRoute() method to get resulting itinerary
	 */
	public class BaseRequest {
		private IItineraryRequestListener mListener = null;

		private int mID = CommonConstants.NULL_ID;

		private Itinerary mRoute = null;
		private boolean mIsPmr = false;

		/***
		 * 
		 * @param id
		 * @param listener
		 * @param disabled
		 */
		public BaseRequest(int id, IItineraryRequestListener listener, boolean disabled) {
			mID = id;
			mListener = listener;
			mIsPmr = disabled;
		}

		/**
		 * Returns the id of this request.
		 * @return the ID of this Request
		 */
		public int getID() {
			return mID;
		}

		/**
		 * Get the itinerary calculated for this request
		 * @return the itinerary from the departure to the arrival.  
		 */
		public Itinerary getRoute() {
			return mRoute;
		}

		/**
		 * @hide
		 * @param route
		 */
		public void setRoute(Itinerary route) {
			mRoute = route;
		}

		/**
		 * Return the {@link IItineraryRequestListener} associated to this request.
		 * @return The {@link IItineraryRequestListener} associated to this request
		 */
		public IItineraryRequestListener getListener() {
			return mListener;
		}

		/**
		 * Return true if this request is tagged for PMR
		 * @return True if tagged for PMR.
		 */
		public boolean isPmr(){
			return mIsPmr;
		}

		/**
		 * Recompute this current {@link BaseRequest}. In the case of an {@link ItineraryRequest} using the location
		 * the user's position will be updated to the last one know for the recomputation.
		 */
		public void recompute() {
		}

		/**
		 * @hide
		 * @param success
		 * @param error
		 */
		public void notifyRequestDone(boolean success, InsiteoError error){
			if (mListener != null) {
				mListener.onItineraryRequestDone(success, this, error);
			}
			if (mItinerary != null) {
				mItinerary.setItinerary((success) ? mRoute : null);
			}
		}


	}
}

  </pre>
</div>
<div id="footer">
Generated by <a href="http://code.google.com/p/doclava/">Doclava</a>.
</div> <!-- end footer -->

</div> <!-- jd-content -->

</div><!-- end doc-content -->

</div> <!-- end body-content --> 

<script type="text/javascript">
init(); /* initialize doclava-developer-docs.js */
</script>

</body>
</html>
