<!DOCTYPE html>

















































<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <meta name="description" content="Javadoc API documentation for Insiteo API Documentation - Version 3.2.0_RC1." />

<link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.ico" />
<title>

  InitProvider


| Insiteo API Documentation - Version 3.2.0_RC1

</title>
<link href="../../../../../../assets/doclava-developer-docs.css" rel="stylesheet" type="text/css" />
<link href="../../../../../../assets/customizations.css" rel="stylesheet" type="text/css" />
<script src="../../../../../../assets/search_autocomplete.js" type="text/javascript"></script>
<script src="../../../../../../assets/jquery-resizable.min.js" type="text/javascript"></script>
<script src="../../../../../../assets/doclava-developer-docs.js" type="text/javascript"></script>
<script src="../../../../../../assets/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  setToRoot("../../../../../", "../../../../../../assets/");
</script>
<script src="../../../../../../assets/doclava-developer-reference.js" type="text/javascript"></script>
<script src="../../../../../../assets/navtree_data.js" type="text/javascript"></script>
<script src="../../../../../../assets/customizations.js" type="text/javascript"></script>
<noscript>
  <style type="text/css">
    html,body{overflow:auto;}
    #body-content{position:relative; top:0;}
    #doc-content{overflow:visible;border-left:3px solid #666;}
    #side-nav{padding:0;}
    #side-nav .toggle-list ul {display:block;}
    #resize-packages-nav{border-bottom:3px solid #666;}
  </style>
</noscript>
</head>

<body class="">

<div id="header">
    <div id="headerLeft">
    
      <span id="masthead-title">Insiteo API Documentation - Version 3.2.0_RC1</span>
    
    </div>
    <div id="headerRight">
      
  <div id="search" >
      <div id="searchForm">
          <form accept-charset="utf-8" class="gsc-search-box" 
                onsubmit="return submit_search()">
            <table class="gsc-search-box" cellpadding="0" cellspacing="0"><tbody>
                <tr>
                  <td class="gsc-input">
                    <input id="search_autocomplete" class="gsc-input" type="text" size="33" autocomplete="off"
                      title="search developer docs" name="q"
                      value="search developer docs"
                      onFocus="search_focus_changed(this, true)"
                      onBlur="search_focus_changed(this, false)"
                      onkeydown="return search_changed(event, true, '../../../../../')"
                      onkeyup="return search_changed(event, false, '../../../../../')" />
                  <div id="search_filtered_div" class="no-display">
                      <table id="search_filtered" cellspacing=0>
                      </table>
                  </div>
                  </td>
                  <td class="gsc-search-button">
                    <input type="submit" value="Search" title="search" id="search-button" class="gsc-search-button" />
                  </td>
                  <td class="gsc-clear-button">
                    <div title="clear results" class="gsc-clear-button">&nbsp;</div>
                  </td>
                </tr></tbody>
              </table>
          </form>
      </div><!-- searchForm -->
  </div><!-- search -->
      
        
  <div id="api-level-toggle">
    <input type="checkbox" id="apiLevelCheckbox" onclick="toggleApiLevelSelector(this)" />
    <label for="apiLevelCheckbox" class="disabled">Filter by API Level: </label>
    <select id="apiLevelSelector">
      <!-- option elements added by buildApiLevelSelector() -->
    </select>
  </div>
  <script>
   var SINCE_DATA = [ 'v1', 'v1' ];
    
    var SINCE_LABELS = [ 'v1', 'v1' ];
    buildApiLevelSelector();
    addLoadEvent(changeApiLevel);
  </script>


      
    </div>
</div><!-- header -->


  <div class="g-section g-tpl-240" id="body-content">
    <div class="g-unit g-first side-nav-resizable" id="side-nav">
      <div id="swapper">
        <div id="nav-panels">
          <div id="resize-packages-nav">
            <div id="packages-nav">
              <div id="index-links">
                <a href="../../../../../packages.html"  >Package Index</a> | 
                <a href="../../../../../classes.html" >Class Index</a>
              </div>
              <ul>
                
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/analytics/package-summary.html">com.insiteo.lbs.analytics</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/analytics/entities/package-summary.html">com.insiteo.lbs.analytics.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/common/package-summary.html">com.insiteo.lbs.common</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/common/auth/package-summary.html">com.insiteo.lbs.common.auth</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/common/auth/entities/package-summary.html">com.insiteo.lbs.common.auth.entities</a></li>
    <li class="selected api apilevel-">
  <a href="../../../../../com/insiteo/lbs/common/init/package-summary.html">com.insiteo.lbs.common.init</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/geofence/package-summary.html">com.insiteo.lbs.geofence</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/geofence/render/package-summary.html">com.insiteo.lbs.geofence.render</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/itinerary/package-summary.html">com.insiteo.lbs.itinerary</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/itinerary/entities/package-summary.html">com.insiteo.lbs.itinerary.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/location/package-summary.html">com.insiteo.lbs.location</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/location/utils/package-summary.html">com.insiteo.lbs.location.utils</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/package-summary.html">com.insiteo.lbs.map</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/database/package-summary.html">com.insiteo.lbs.map.database</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/entities/package-summary.html">com.insiteo.lbs.map.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/gestures/package-summary.html">com.insiteo.lbs.map.gestures</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/render/package-summary.html">com.insiteo.lbs.map.render</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/utils/package-summary.html">com.insiteo.lbs.map.utils</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/meetme/package-summary.html">com.insiteo.lbs.meetme</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/meetme/requests/package-summary.html">com.insiteo.lbs.meetme.requests</a></li>
              </ul><br/>
            </div> <!-- end packages -->
          </div> <!-- end resize-packages -->
          <div id="classes-nav">
            <ul>
              
    <li><h2>Interfaces</h2>
      <ul>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/common/init/IInitListener.html">IInitListener</a></li>
      </ul>
    </li>
              
    <li><h2>Classes</h2>
      <ul>
          <li class="selected api apilevel-"><a href="../../../../../com/insiteo/lbs/common/init/InitProvider.html">InitProvider</a></li>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/common/init/Package.html">Package</a></li>
      </ul>
    </li>
              
              
    <li><h2>Enums</h2>
      <ul>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/common/init/EInitResult.html">EInitResult</a></li>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/common/init/EPackageType.html">EPackageType</a></li>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/common/init/InitProvider.Server.html">InitProvider.Server</a></li>
      </ul>
    </li>
              
              
            </ul><br/>
          </div><!-- end classes -->
        </div><!-- end nav-panels -->
        <div id="nav-tree" style="display:none">
          <div id="index-links">
            <a href="../../../../../packages.html"  >Package Index</a> | 
            <a href="../../../../../classes.html" >Class Index</a>
          </div>
        </div><!-- end nav-tree -->
      </div><!-- end swapper -->
    </div> <!-- end side-nav -->
    <script>
      if (!isMobile) {
        $("<a href='#' id='nav-swap' onclick='swapNav();return false;' style='font-size:10px;line-height:9px;margin-left:1em;text-decoration:none;'><span id='tree-link'>Use Tree Navigation</span><span id='panel-link' style='display:none'>Use Panel Navigation</span></a>").appendTo("#side-nav");
        chooseDefaultNav();
        if ($("#nav-tree").is(':visible')) {
          init_default_navtree("../../../../../");
        } else {
          addLoadEvent(function() {
            scrollIntoView("packages-nav");
            scrollIntoView("classes-nav");
          });
        }
        $("#swapper").css({borderBottom:"2px solid #aaa"});
      } else {
        swapNav(); // tree view should be used on mobile
      }
    </script>



<div class="g-unit" id="doc-content">

<div id="api-info-block">



  
   
  
  
  
  

  
   
  
  
  
  


<div class="sum-details-links">

<div>
<a href="InitProvider.html">View Documentation</a>
</div>


</div><!-- end sum-details-links -->
<div class="api-level">
  

  Since: <a href="../../../../../guide/appendix/api-levels.html#level">API Level </a>


  
  

</div>
</div><!-- end api-info-block -->


<!-- ======== START OF CLASS DATA ======== -->

<div id="jd-header">
    public
     
     
    
    class
<h1>InitProvider</h1>



  
    extends <a href="http://d.android.com/reference/java/lang/Object.html">Object</a><br/>
  
  
  

  
  
      implements 
      
        <a href="../../../../../com/insiteo/lbs/common/init/IInitListener.html">IInitListener</a> 
      
  
  


</div><!-- end header -->
<div id="jd-content">
  <pre class="prettyprint">
package com.insiteo.lbs.common.init;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Stack;

import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.graphics.PointF;
import android.os.Environment;
import android.os.SystemClock;
import android.util.SparseArray;
import android.view.WindowManager;

import com.insiteo.lbs.R;
import com.insiteo.lbs.analytics.AnalyticsManager;
import com.insiteo.lbs.common.CommonConstants;
import com.insiteo.lbs.common.IDebugListener;
import com.insiteo.lbs.common.InsiteoError;
import com.insiteo.lbs.common.TileIndex;
import com.insiteo.lbs.common.database.RODBHelper;
import com.insiteo.lbs.common.parser.BaseInitResponseParser;
import com.insiteo.lbs.common.parser.ProtoLoader;
import com.insiteo.lbs.common.utils.Log;
import com.insiteo.lbs.common.utils.threading.ICancelable;
import com.insiteo.lbs.map.MapConstants;
import com.insiteo.lbs.map.database.MapDBHelper;
import com.insiteo.lbs.map.entities.Map;
import com.insiteo.lbs.map.entities.Zone;
import com.insiteo.lbs.map.render.EZoneAction;
import com.insiteo.lbs.map.tiledmap.ZoomLevel;
import com.insiteo.lbs.protobuf.model.map.ProtoMapPoint.PBMapPoint;
import com.insiteo.lbs.protobuf.model.map.ProtoMapTile.PBMapTile;
import com.insiteo.lbs.protobuf.model.map.ProtoMapZone.PBMapZone;
import com.insiteo.lbs.protobuf.model.map.ProtoMapZones.PBMapZones;

/**
 * Singleton that handles initialization of Insiteo API.
 * It will store useful information such as data version, or URLs for requests.
 * Be sure to call {@link #initAPI(Activity, IInitListener, Package, boolean, boolean, String, int, int, String) init} before using other insiteo modules.
 */
public class InitProvider implements IInitListener {	

	private static final String TAG = InitProvider.class.getSimpleName();

	private long mLastDataUpdateTime = 0;
	private long mLastInitTime = 0;

	private String mInitUrl = null;
	private int mSiteId = CommonConstants.NULL_ID;
	private String mLang = null;
	private int mAppVersion = CommonConstants.NULL_VERSION;
	
	private int mMapRootId;

	private String mContentUrl = null;
	private String mMapsUrl = null;
	private String mLbsUrl = null;
	private String mAnalyticsUrl = null;

	private Context mApplicationContext = null;
	private boolean mAnalyticsAutoStart = false;

	private Stack&lt;Package&gt; mRemotePackagesAvailable;
	private Stack&lt;Package&gt; mPackagesToUpdate;
	private Stack&lt;Package&gt; mPackagesDownloaded;


	private String mExternalStoragePath = null;
	private String mRODataDirPath = null;
	private String mRWDataDirPath = null;
	private InsiteoError mError = null;
	private volatile boolean mIsInitialised = false;
	private static InitProvider sInstance = null;

	private WeakReference&lt;IInitListener&gt; mListener = null;
	private WeakReference&lt;Activity&gt; mContext = null;

	private SparseArray&lt;Zone&gt; mZones = null; 
	private SparseArray&lt;Map&gt; mMaps = null;

	private HashMap&lt;String, RODBHelper&gt; mDBHelpers = null;

	private IDebugListener mDebugListener;


	/**
	 * Defines the server used. By default it is set to Server.PROD
	 */
	private Server mServer = Server.PROD;

	/**
	 * This enum is used to defined the type of server used. Files downloaded will be store in a specific
	 * directory depending on this value.
	 */
	public enum Server{
		/**
		 * Files will be stored under the 'dev' directory.
		 */
		DEV,
		/**
		 * Files will be stored under the 'test' directory.
		 */
		TEST,
		/**
		 * Files will be stored under the 'release' directory.
		 */
		PROD
	}


	public Context getApplicationContext(){
		return mApplicationContext;
	}
	
	/**
	 * private constructor
	 */
	private InitProvider() {
		mRemotePackagesAvailable = new Stack&lt;Package&gt;();
		mZones = new SparseArray&lt;Zone&gt;(0); 
		mMaps = new SparseArray&lt;Map&gt;(0);
		mListener = new WeakReference&lt;IInitListener&gt;(null);
		mDBHelpers = new HashMap&lt;String, RODBHelper&gt;();
	}

	/**
	 * Get InitProvider instance
	 * @return the InitProvider unique instance
	 */
	public static InitProvider getInstance() {
		if (sInstance == null) {
			sInstance = new InitProvider();
		}
		return sInstance;
	}

	//******************************************************************************************************************
	// Screen lock
	// *****************************************************************************************************************

	private void lockScreen() {
		if(mContext != null) {
			if(mContext.get() instanceof Activity) {
				((Activity) mContext.get()).runOnUiThread(new Runnable() {
					@Override
					public void run() {
						((Activity) mContext.get()).getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
					}
				});
			}
		}
	}

	private void unlockScreen() {
		if(mContext != null) {
			if(mContext.get() instanceof Activity) {
				((Activity) mContext.get()).runOnUiThread(new Runnable() {
					@Override
					public void run() {
						((Activity) mContext.get()).getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
					}
				});
			}
		}
	}

	//******************************************************************************************************************
	// DEBUG
	// *****************************************************************************************************************

	/**
	 * @hide
	 * @param listener
	 */
	public void setDebugListener(IDebugListener listener) {
		mDebugListener = listener;
	}

	/**
	 * @hide
	 * @return
	 */
	public IDebugListener getDebugListener() {
		return mDebugListener;
	}

	//******************************************************************************************************************
	// API AUTHENTICATION
	// *****************************************************************************************************************

	/**
	 * Sets the Insiteo authentication API Key that was provided when you registered to our services. 
	 * This key is required in order to start the API.
	 * @param key
	 */
	public void setAPIKey(String key){
		CommonConstants.API_KEY = key;
	}


	//******************************************************************************************************************
	// API INITIALIZATION
	// *****************************************************************************************************************	

	/**
	 * Equivalent to {@link #startAPI(Activity, IInitListener, Package, boolean, boolean, String, int, int, String)} with a null masterpackage, the PROD server and analytics OFF by default.
	 */
	public ICancelable startAPI(final Activity aContext, final IInitListener aListener, String aInitUrl, int aSiteId, int aAppVersion, String aLang) {
		return startAPI(aContext, aListener, aInitUrl, aSiteId, aAppVersion, aLang, Server.PROD, true);
	}

	/**
	 * Request for API initialization. This is an asynchronous call : results will be send via aListener's callbacks. This method will return an ICancelable that allow you to stop the background init task. 
	 * @param aContext the context in which init will be done
	 * @param aListener the listener that will receive init notifications. The listener is stored as a &lt;code&gt;WeakReference&lt;/code&gt; : be careful to keep a reference on it in your code if you want to receive notifications. 
	 * @param aMasterPackage a PackageDescriptor for a zip file containing data for insiteo modules : type should be &lt;code&gt;FULL&lt;/code&gt;, url is the path of the zip file, md5 is the md5 sum of the zip file, version and size are not used. If null, data will be downloaded only when needed.
	 * @param aMasterPackageInAssets if true, zip file will be loaded from assets, otherwise it will be loaded as a regular file. aMasterPackage.getUrl() will be used to know the file path.
	 * @param aForceMasterPackage if true, master package will be deployed on sdcard, even if it is already deployed
	 * @param aInitUrl the url of the init request
	 * @param aSiteId the site ID of the calling application
	 * @param aAppVersion the application code version of the calling application
	 * @param aLang the locale of the calling application 
	 * @param aServer the server the application is used on
	 * @return an ICancelable object, representing the init task that is running background. Call &lt;code&gt;cancel()&lt;/code&gt; on it to stop the init task (before you kill aContext for example).
	 */
	public ICancelable startAPI(final Activity aContext, final IInitListener aListener,
			String aInitUrl, int aSiteId, int aAppVersion, String aLang, Server aServer, boolean aAnalyticsAutoStart) {

		mLastInitTime = System.currentTimeMillis();

		mListener = new WeakReference&lt;IInitListener&gt;(aListener);
		mContext = new WeakReference&lt;Activity&gt;(aContext);
		mApplicationContext = aContext.getApplicationContext();
		mSiteId = aSiteId;
		mLang = aLang;
		mAppVersion = aAppVersion;
		mInitUrl = aInitUrl;
		mServer = aServer;

		mAnalyticsAutoStart = aAnalyticsAutoStart;

		lockScreen();

		InitTask initTask = new InitTask();
		Thread t = new Thread(initTask);
		t.start();

		// Stop analytics API if it was started
		if (AnalyticsManager.getInstance().isStarted()) {
			AnalyticsManager.getInstance().stop();
		}


		return initTask;
	}

	//******************************************************************************************************************
	// PACKAGES UPDATE
	// *****************************************************************************************************************

	/**
	 * Update all data for insiteo modules. This method will download and install packages containing all available data for the site defined at init. 
	 * Download and install are running asynchronously : aListener will be notified of progress.
	 * @param aContext the context in which this task will run.
	 * @param aListener the listener that will receive progress notification. If null, you won't receive notification.
	 * @param aForceUpdate if false, only the new packages will be installed ; if true all packages will be downloaded and installed, even if they are already deployed
	 * @return an ICancelable object. Call cancel() on this ICancelable to abort this update (no notification will be sent after cancel).
	 */
	public ICancelable updatePackages(Activity aContext, IInitListener aListener, boolean aForceUpdate) {

		if (aForceUpdate) {
			return updatePackages(aContext, aListener, mRemotePackagesAvailable);
		} else {
			return updatePackages(aContext, aListener, mPackagesToUpdate);
		}
	}

	/**
	 * Update all data for insiteo modules. This method will download and install only the mist of selected packages containing all available data for the site defined at init. 
	 * Download and install are running asynchronously : aListener will be notified of progress.
	 * @param aContext the context in which this task will run.
	 * @param aListener the listener that will receive progress notification. If null, you won't receive notification.
	 * @return an ICancelable object. Call cancel() on this ICancelable to abort this update (no notification will be sent after cancel).
	 */
	@SuppressWarnings("unchecked")
	public ICancelable updatePackages(Activity aContext, IInitListener aListener, Stack&lt;Package&gt; aPackagesToUpdate) {
		mListener = new WeakReference&lt;IInitListener&gt;(aListener);
		PackageUpdater pu = new PackageUpdater(aContext, this);

		mPackagesDownloaded = aPackagesToUpdate;

		//close all DBHelpers to avoid problems while moving/deleting files
		closeDBHelpers(false);

		// Stop analytics API if it was started
		if (AnalyticsManager.getInstance().isStarted()) {
			AnalyticsManager.getInstance().stop();
		}

		lockScreen();
		
		if (aPackagesToUpdate != null) {
			pu.updatePackages((Stack&lt;Package&gt;) aPackagesToUpdate.clone(), mRODataDirPath);
		} else {
			// Launch the update process even if the package list is null to notify on update done
			pu.updatePackages(null, mRODataDirPath);
		}


		return pu;
	}

	//******************************************************************************************************************
	//  DB repository
	// *****************************************************************************************************************

	/**
	 * @hide
	 * Application should not use this method directly.
	 * Register a database helper and tries to open it directly. The InitProvider will handle the open/close of those DBHelper
	 * when updating data.
	 * @param aDBHelper the DB helper to register
	 * @param aName The name that will be used to store the database.
	 * @return true if the database is opened
	 */
	public boolean registerDBHelper(RODBHelper aDBHelper, String aName) {
		boolean isOpened = false;
		isOpened = aDBHelper.open();
		mDBHelpers.put(aName, aDBHelper);
		return isOpened;

	}

	/**
	 * Get path to insiteo read-only data
	 * @return
	 */
	private String initDataDirPath() {
		String path;
		switch (mServer) {
		case TEST:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "test" + "/" + mSiteId + "/" + mAppVersion + "/" + mLang;
			break;
		case DEV:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "dev" + "/" + mSiteId + "/" + mAppVersion + "/" + mLang;
			break;
		default:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "release" + "/" + mSiteId + "/" + mAppVersion + "/" + mLang;
			break;
		}
		return path;
	}

	/**
	 * get path to insiteo read-write data
	 * @return
	 */
	private String initRWDataDirPath() {
		String path = "";
		Context context = mContext.get();

		if (context != null) {
			File f = context.getDir(CommonConstants.DATA_DIRECTORY, Context.MODE_PRIVATE);
			if (f != null) {
				path = f.getAbsolutePath() + "/" + mSiteId;
				f = new File(path);
				f.mkdirs();
			}
		}
		return path;
	}

	/**
	 * open all DBHelpers. Do it in reverse order, thus adding in mDBHelpers does not need mutex.
	 */
	private void initDBHelpers() {
		Set&lt;String&gt; keys = mDBHelpers.keySet();
		Iterator&lt;String&gt; dbIter = keys.iterator();

		while (dbIter.hasNext()) {
			String key = dbIter.next();
			RODBHelper dbHelper = mDBHelpers.get(key);
			dbHelper.setDBPath();
			dbHelper.open();
		}
	}

	/**
	 * Closes all the DBHelpers. This is call when the application's data are being downloaded or updated.
	 * This process only closes the database that belong to the EPackageTypes that are being downloaded.
	 * Do it in reverse order.
	 * @param forceClose if set to true all the databases will be closed ow only the one from the package being modified
	 */
	private void closeDBHelpers(boolean forceClose) {
		Set&lt;String&gt; keys = mDBHelpers.keySet();
		Iterator&lt;String&gt; dbIter = keys.iterator();

		while (dbIter.hasNext()) {
			String key = dbIter.next();

			if (forceClose) {
				RODBHelper dbHelper = mDBHelpers.get(key);
				dbHelper.close();
			} else {
				if (mPackagesDownloaded != null) {
					for (int i = 0; i &lt; mPackagesDownloaded.size(); i++) {
						if (mPackagesDownloaded.get(i).getType().getDirName().equals(key)) {
							RODBHelper dbHelper = mDBHelpers.get(key);
							dbHelper.close();
						}
					}
				}	
			}
		}
	}

	//******************************************************************************************************************
	//  IInitListener
	// *****************************************************************************************************************

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onInstallProgress(long aCurrentFile, long aTotalFiles) {
		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onInstallProgress(aCurrentFile, aTotalFiles);
		}
	}

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onDataUpdateDone(boolean aSuccess, InsiteoError aError) {

		Log.d(TAG, "onDataUpdateDone");

		onSiteContextChanged();

		mLastDataUpdateTime = SystemClock.elapsedRealtime();

		unlockScreen();
		
		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onDataUpdateDone(aSuccess, aError);
		}
		
		mListener.clear();
	}

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onInitDone(EInitResult aResult, InsiteoError aError) {
		//close then re-open dbhelpers
		closeDBHelpers(true);

		onSiteContextChanged();
		
		unlockScreen();

		//notify lister if any
		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onInitDone(aResult, mError);
		}

		mListener.clear();
	}

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onDownloadProgress(long aDownloadedBytes, long aTotalBytes) {
		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onDownloadProgress(aDownloadedBytes, aTotalBytes);
		}
	}

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onPackageDowloadBegin(EPackageType aPkgType) {
		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onPackageDowloadBegin(aPkgType);
		}		
	}

	//******************************************************************************************************************
	//  Map 
	// *****************************************************************************************************************

	private void loadMapData() {
		if(hasPackage(EPackageType.MAPDATA)) {
			mMaps = MapDBHelper.getMapsIndexed(CommonConstants.DEBUG);

			setZoomLevels(mMaps);

			mZones = parseZones();
		}
	}

	private void setZoomLevels(SparseArray&lt;Map&gt; maps) {
		for (int i = 0 ; i &lt; maps.size(); i++) {
			Map map = maps.valueAt(i);

			SparseArray&lt;ZoomLevel&gt; zoomLevels = MapDBHelper.getZoomLevels(map.getId());

			map.setZoomLevels(zoomLevels);

			if (zoomLevels == null) {
				Log.d("map", "Error while loading zoomLevels for map " + map.getId());
			}
		}
	}

	private SparseArray&lt;Zone&gt; parseZones() {
		SparseArray&lt;Zone&gt; zones = null;

		File protoZonesFile = new File(getDataDirPath() + "/" + EPackageType.MAPDATA.getDirName() + "/" + MapConstants.ZONES_FILE_NAME);

		if (protoZonesFile.exists() &amp;&amp; protoZonesFile.isFile()) {
			try {
				//parse protobuf data
				InputStream protoStream = new BufferedInputStream(new FileInputStream(protoZonesFile));
				PBMapZones root = PBMapZones.parseFrom(protoStream);
				zones = new SparseArray&lt;Zone&gt;(root.getZonesCount());

				//iterate over protobuff zones and create GfxZones
				List&lt;PBMapZone&gt; pbMZs = root.getZonesList();
				Iterator&lt;PBMapZone&gt; pbIte = pbMZs.iterator(); 
				while (/*!mCancel &amp;&amp; */pbIte.hasNext()) {
					PBMapZone pbMZ = pbIte.next();

					//create polygon array
					ArrayList&lt;PointF&gt; polygon = new ArrayList&lt;PointF&gt;(pbMZ.getPolygonCount());
					for (PBMapPoint mp : pbMZ.getPolygonList()) {
						polygon.add(new PointF(mp.getX(), mp.getY()));
					}

					//create index array
					ArrayList&lt;TileIndex&gt; tileIndex = new ArrayList&lt;TileIndex&gt;(pbMZ.getTilesListCount());
					for (PBMapTile mt : pbMZ.getTilesListList()) {
						tileIndex.add(new TileIndex(pbMZ.getMapId(), mt.getX(), mt.getY(), mt.getZoom()));
					}

					Zone zone = new Zone(pbMZ.getZoneId(), pbMZ.getGuid(), (pbMZ.hasDispLabel()) ? pbMZ.getDispLabel() : null, pbMZ.getZoneTypeId(), pbMZ.getMapId(),  pbMZ.getCoord().getX(),  pbMZ.getCoord().getY(), pbMZ.getZ(),
							pbMZ.getZoomMin(), pbMZ.getZoomMax(), polygon, tileIndex, pbMZ.getDispSortIndex(), pbMZ.getComments(), !pbMZ.getIsHiddenZone());

					//set action
					if (pbMZ.hasActionType()) {
						zone.setActionParam(EZoneAction.getFromValue(pbMZ.getActionType()), pbMZ.getActionParameter());
					}

					if (pbMZ.hasExtra1()) {
						zone.setExtra1(pbMZ.getExtra1());
					}
					if (pbMZ.hasExtra2()) {
						zone.setExtra2(pbMZ.getExtra2());
					}
					if (pbMZ.hasExtra3()) {
						zone.setExtra3(pbMZ.getExtra3());
					}
					if (pbMZ.hasExtra4()) {
						zone.setExtra4(pbMZ.getExtra4());
					}
					if (pbMZ.hasExtra5()) {
						zone.setExtra5(pbMZ.getExtra5());
					}


					if (pbMZ.hasFextra1()) {
						zone.setFExtra1(pbMZ.getFextra1());
					}


					if (pbMZ.hasDispExtra1()) {
						zone.setDispExtra1(pbMZ.getDispExtra1());
					}
					if (pbMZ.hasDispExtra2()) {
						zone.setDispExtra2(pbMZ.getDispExtra2());
					}
					if (pbMZ.hasDispExtra3()) {
						zone.setDispExtra3(pbMZ.getDispExtra3());
					}


					if (pbMZ.hasDispFextra1()) {
						zone.setDispFExtra1(pbMZ.getDispFextra1());
					}

					//add zone in list
					zones.put(zone.getId(), zone);
				}
			} catch (Exception e) {
				Log.d(TAG, "Unable parse protobuf file :", e);
				zones = null;
			}
		}
		return zones;
	}
	
	/**
	 * Returns the site root {@link Map#getId()} 
	 * @return the root map id
	 */
	public int getMapRootId() {
		return mMapRootId;
	}
	
	/**
	 * @hide
	 * @param id
	 */
	public void setMapRootId(int id) {
		mMapRootId = id;
	}
	
	/**
	 * Returns the {@link Map} corresponding too the given id.
	 * @param id the id of the requested {@link Map}.
	 * @return the corresponding {@link Map}.
	 */
	public Map getMap(int id) {
		return mMaps.get(id);
	}

	/**
	 * Returns a {@link SparseArray} containing all the {@link Map} of the
	 * current site.
	 * @return a {@link SparseArray} containing all the {@link Map}.
	 */
	public SparseArray&lt;Map&gt; getMaps() {
		return mMaps;
	}

	/**
	 * Return the {@link Zone} corresponding to the given id.
	 * @param aZoneID the zone id.
	 * @return the corresponding {@link Zone}.
	 */
	public Zone getZone(int aZoneID) {
		return mZones.get(aZoneID);
	}

	/**
	 * @hide
	 * Sets the {@link Map} of the current site.
	 * @param aMaps
	 */
	public void setMaps(SparseArray&lt;Map&gt; aMaps) {
		if (aMaps != null) {
			mMaps = aMaps;
		}
	}

	/**
	 * @hide
	 * Sets the {@link Zone} for the current site.
	 * @param aZones
	 */
	public void setZones(SparseArray&lt;Zone&gt; aZones) {
		if (aZones != null) {
			mZones = aZones;
		}
	}

	/**
	 * Returns all the {@link Map} sorted according to their {@link Map#getSortIndex()}.
	 * @return a {@link List} containing all the {@link Map} sorted.
	 */
	public List&lt;Map&gt; getSortedMaps(){
		List&lt;Map&gt; result = new ArrayList&lt;Map&gt;();

		for (int i = 0; i &lt; mMaps.size(); i++) {
			result.add(mMaps.valueAt(i));
		}

		Collections.sort(result, new Comparator&lt;Map&gt;() {
			@Override
			public int compare(final Map object1, final Map object2) {
				int result;
				if(object1.getSortIndex() &lt; object2.getSortIndex()){
					result = -1;
				} else if (object1.getSortIndex()  ==  object2.getSortIndex()) {
					result = 0;
				} else {
					result = 1;
				}
				return result;
			}
		} );
		return result;
	}

	/**
	 * Returns all the {@link Zone} for the current site.
	 * @return a {@link SparseArray} containing all the {@link Zone}.
	 */
	public SparseArray&lt;Zone&gt; getZones() {
		return mZones;
	}

	
	private void onSiteContextChanged() {
		// 1 - Reopen database
		initDBHelpers();

		// 2 - Analytics
		initializeAnalytics();

		// 3 - Zone init
		loadMapData();
	}
	
	//******************************************************************************************************************
	//  ACCESSORS
	// *****************************************************************************************************************

	/**
	 * Set the default language in shared prefs
	 * @param aDefaultLanguage the default language for the current site 
	 */
	void setDefaultLanguage(String aDefaultLanguage) {
		Context context = mContext.get();
		if (context != null) {
			SharedPreferences prefs = context.getSharedPreferences(CommonConstants.PREFERENCES_BUNDLE_NAME, Context.MODE_PRIVATE);
			Editor edit = prefs.edit();
			if (aDefaultLanguage != null) {
				edit.putString(CommonConstants.PREF_DEFAULT_LANGUAGE, aDefaultLanguage);
				edit.commit();
			}
		}
	}

	/**
	 * Get the default language stored in shared prefs
	 * @return the default language if defined, null otherwise.
	 */
	String getDefaultLanguage() {
		String lang = null;
		Context context = mContext.get();
		if (context != null) {
			SharedPreferences prefs = context.getSharedPreferences(CommonConstants.PREFERENCES_BUNDLE_NAME, Context.MODE_PRIVATE);
			lang = prefs.getString(CommonConstants.PREF_DEFAULT_LANGUAGE, null);
		}
		return lang;
	}	

	/**
	 * Check if a package of the given type is already deployed
	 * @param aType the type of package to check
	 * @return true if a package of the given type is already deployed, false otherwise
	 */
	public boolean hasPackage(EPackageType aType) {
		boolean result = false;
		File f = new File(mRODataDirPath + "/" + aType.getDirName() + "/" + CommonConstants.VERSION_FILENAME);
		if (f != null &amp;&amp; f.exists()) {
			result = true;
		}
		return result;
	}

	/**
	 * Get the time of the last package deployment (gotten through SystemClock.elapsedRealTime)
	 * @return the time of last data update (in millisecond), or 0 if no data update was done
	 */
	public long getLastDataUpdateTime() {
		return mLastDataUpdateTime;
	}

	/**
	 * @return true if the InitProvider is initialized
	 */
	public boolean isInitialized()  {
		return mIsInitialised;
	}
	/**
	 * Get the last error of the InitProvider 
	 * @return the last error that happened in InitProvider
	 */
	public InsiteoError getError() {
		return mError;
	}
	/**
	 * Get path to external storage (ie : sdcard)
	 * @return the path to external storage
	 */
	public String getExternalStoragePath() {
		return mExternalStoragePath;
	}
	/**
	 * Get path to insiteo read-only data directory
	 * @return the path to insiteo RO data directory
	 */
	public String getDataDirPath() {
		return mRODataDirPath;
	}

	/**
	 * Returns the root path of the data directory 
	 * ie RootDirectoryPath + ServerTypePath + siteId
	 */
	public String getDataDirRootPath(){
		String path;
		switch (mServer) {
		case TEST:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "test" + "/" + mSiteId;
			break;
		case DEV:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "dev" + "/" + mSiteId;
			break;
		default:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "release" + "/" + mSiteId;
			break;
		}
		return path;
	}

	/**
	 * Get path to insiteo read-write data directory
	 * @return the path to insiteo RW data directory
	 */
	public String getRWDataDirPath() {
		return mRWDataDirPath;
	}
	/**
	 * @return the url used to initialize the API
	 */
	public String getInitUrl() {
		return mInitUrl;
	}
	/**
	 * @return the site ID used to initialize the API
	 */
	public int getSiteId() {
		return mSiteId;
	}
	/**
	 * @return the locale used to initialize the API
	 */
	public String getLang() {
		return mLang;
	}
	/**
	 * @return the application code version used to initialize the API
	 */
	public int getAppVersion() {
		return mAppVersion;
	}
	/**
	 * @return the url for lbs requests
	 */
	public String getLbsUrl() {
		return mLbsUrl;
	}
	/**
	 * @return the url for content requests
	 */
	public String getContentUrl() {
		return mContentUrl;
	}
	/**
	 * @return the url for maps requests
	 */
	public String getMapsUrl() {
		return mMapsUrl;
	}

	/**
	 * @hide
	 * @return the url for analytics requests
	 */
	public String getAnalyticsUrl() {
		return mAnalyticsUrl;
	}

	/**
	 * Method to get the packages that are required to be updated
	 * @return
	 */
	public Stack&lt;Package&gt; getPackagesToUpdate(){
		return mPackagesToUpdate;
	}

	/**
	 * Method to get all the packages available for this site. Should be called after initialization process and if
	 * initialization succeeded.
	 * @return The stack of all the available packages.
	 */
	public Stack&lt;Package&gt; getRemotePackagesAvailable(){
		return mRemotePackagesAvailable;
	}

	/**
	 * Returns a {@link List} of all the {@link Package} correponding to the packages already deployed on the phone
	 * for the current site.
	 * @return
	 */
	public Stack&lt;Package&gt; getLocalPackagesAvailable(){
		Stack&lt;Package&gt; packages = new Stack&lt;&gt;();

		if(hasPackage(EPackageType.LOCATION)){
			int locationVersion = EPackageType.LOCATION.getVersion();
			Package pd = new Package(EPackageType.LOCATION, null, locationVersion, null, 0);
			packages.add(pd);
		}

		if(hasPackage(EPackageType.ITINERARY)){
			int itineraryVersion = EPackageType.ITINERARY.getVersion();
			Package pd = new Package(EPackageType.ITINERARY, null, itineraryVersion, null, 0);
			packages.add(pd);
		}

		if(hasPackage(EPackageType.GEOFENCING)) {
			int geofencingVersion = EPackageType.GEOFENCING.getVersion();
			Package pd = new Package(EPackageType.GEOFENCING, null, geofencingVersion, null, 0);
			packages.add(pd);
		}

		if(hasPackage(EPackageType.MAPDATA)) {
			int mapdataVersion = EPackageType.MAPDATA.getVersion();
			Package pd = new Package(EPackageType.MAPDATA, null, mapdataVersion, null, 0);
			packages.add(pd);
		}

		if(hasPackage(EPackageType.TILES)) {
			int tilesVersion = EPackageType.TILES.getVersion();
			Package pd = new Package(EPackageType.TILES, null, tilesVersion, null, 0);
			packages.add(pd);
		}

		if(hasPackage(EPackageType.CONTENTLRR)) {
			int contentLRRVersion = EPackageType.CONTENTLRR.getVersion();
			Package pd = new Package(EPackageType.CONTENTLRR, null, contentLRRVersion, null, 0);
			packages.add(pd);
		}

		if(hasPackage(EPackageType.CONTENTHRR)) {
			int contentHRRVersion = EPackageType.CONTENTHRR.getVersion();
			Package pd = new Package(EPackageType.CONTENTHRR, null, contentHRRVersion, null, 0);
			packages.add(pd);
		}

		if(hasPackage(EPackageType.FINGERPRINT)) {
			int fingerprintVersion = EPackageType.FINGERPRINT.getVersion();
			Package pd = new Package(EPackageType.FINGERPRINT, null, fingerprintVersion, null, 0);
			packages.add(pd);
		}

		if(hasPackage(EPackageType.ANALYTICS)) {
			int analyticsVersion = EPackageType.ANALYTICS.getVersion();
			Package pd = new Package(EPackageType.ANALYTICS, null, analyticsVersion, null, 0);
			packages.add(pd);
		}

		return packages;
	}

	/**
	 * Return the current API version.
	 * @return The version of Insiteo's API.
	 */
	public String getAPIVersion(){
		return CommonConstants.API_VERSION;
	}

	/**
	 * Activates the Insiteo debug mode.
	 * @param enabled True if it should be enabled
	 */
	public void setDebug(boolean enabled) {
		CommonConstants.DEBUG = enabled;
	}

	/**
	 * Returns the last time an API initialization was requested (even if this init failed).
	 * @return mLastInitTime The last initialization time
	 */
	public long getLastInitTime(){

		return mLastInitTime;
	}

	//******************************************************************************************************************
	// Init async task (cancelable)
	// InitTask will listen PackageUpdater notifications, to be aware of the installation state
	// *****************************************************************************************************************

	private class InitTask implements Runnable, ICancelable {

		private volatile boolean mIsCanceled = false;
		private EInitResult mInitRes;

		public InitTask() {
		}

		@Override
		public void cancel(boolean killTask) {
			mIsCanceled = true;
			unlockScreen();
		}

		@Override
		public void run() {
			try {
				Activity context = mContext.get();
				if (context != null &amp;&amp; !mIsCanceled) {				

					mInitRes = EInitResult.FAIL;

					File sdCard = Environment.getExternalStorageDirectory();

					if ((sdCard != null) &amp;&amp; sdCard.canRead()) {
						mExternalStoragePath = sdCard.getCanonicalPath();
					} else {
						// no sd card inserted !
						mError = new InsiteoError(InsiteoError.NO_SDCARD_ERROR_CODE, context.getString(R.string.insiteo_common_error_sdcard_access));
						throw new IOException("Unable to access SD card");
					}


					String initUrl = mInitUrl;
					initUrl += CommonConstants.INIT_BASE_SERVICE; 
					initUrl = initUrl.replace(CommonConstants.URLKEY_SITE_ID, ""+mSiteId)
							.replace(CommonConstants.URLKEY_APP_VERS, ""+mAppVersion)
							.replace(CommonConstants.URLKEY_LANG, mLang);
					mInitRes = initOnline(initUrl);
					
					mRODataDirPath = initDataDirPath();
					mRWDataDirPath = initRWDataDirPath();
					
					mPackagesToUpdate = filterPackagesToUpdate(mRemotePackagesAvailable);

					//check if there is a package to update
					if (mPackagesToUpdate.size() &gt; 0) {
						mInitRes = EInitResult.SUCCESS_WITH_NEW_DATA;
					}
					
					onInitDone(mInitRes, mError);
				}
			} catch(Exception e) {

				//create error message
				String errorMsg = "";
				Activity activity = mContext.get();
				if (activity != null) {
					errorMsg = activity.getString(R.string.insiteo_common_error_unable_to_init_api);
					errorMsg += e.getLocalizedMessage();
				}

				//notify lister if any
				mError = new InsiteoError(InsiteoError.API_NOT_INIT_ERROR_CODE, errorMsg);
				onInitDone(EInitResult.FAIL, mError);
			}
		}

		/**
		 * Make the call to the Insiteo server for the API initialization.
		 */
		private EInitResult initOnline(String url) {
			EInitResult result = EInitResult.FAIL;

			Context context = mContext.get();
			if (context != null &amp;&amp; !mIsCanceled) {

				//load remote data
				BaseInitResponseParser parser = new BaseInitResponseParser();
				if (!mIsCanceled) {
					mError = ProtoLoader.load(url, parser);

					//check init result
					if (InsiteoError.NO_ERROR_CODE.equals(mError.getCode())) {
						//data was loaded successfully
						result = EInitResult.SUCCESS;

						//Save returned lang in sharedprefs if it is the default language (ie : if it is different from mLang)
						if (mLang.equalsIgnoreCase(parser.getLang()) == false) {
							setDefaultLanguage(parser.getLang());
							mLang = parser.getLang();	//update lang with the one returned by server
						}						

						mLbsUrl = parser.getLbsUrl();
						mContentUrl = parser.getContentUrl();
						mMapsUrl = parser.getMapsUrl() + mLang + "/";
						mAnalyticsUrl = parser.getAnalyticsUrl();

						//check which packages need to be updated
						mRemotePackagesAvailable = parser.getPackages();
						
						//set init done
						mIsInitialised = true;
					} else {
						Log.d("Init", "Error during initBase, with code " + mError.getCode());
						//switch to default language if needed
						//set insiteo data path
						if (!new File(mRODataDirPath).isDirectory()) {
							//no package exist for this lang =&gt; try to use default language
							String defLang = getDefaultLanguage();
							if (defLang != null) {
								mLang = defLang;
								mRODataDirPath = initDataDirPath();
							}
						}
					}					
				}
			}

			return result;
		}


		//create the stack of packages that need to be installed
		private Stack&lt;Package&gt; filterPackagesToUpdate(Stack&lt;Package&gt; aPackages) {
			Stack&lt;Package&gt; packagesToUpdate = new Stack&lt;Package&gt;();
			for (Package pd : aPackages) {
				if (!Package.isDeployed(mRODataDirPath, pd.getType(), pd.getVersion())) {
					//the package corresponding to this descriptor is not yet deployed =&gt; add it to the list of packages to update
					packagesToUpdate.push(pd);
				}
			}
			return packagesToUpdate;
		}

	}
	

	//******************************************************************************************************************
	//  Analytics
	// *****************************************************************************************************************

	private void initializeAnalytics(){
		if (hasPackage(EPackageType.ANALYTICS)) {
			if (mAnalyticsAutoStart) {
				AnalyticsManager.getInstance().start(mApplicationContext);
			}
		}
	}
}

  </pre>
</div>
<div id="footer">
Generated by <a href="http://code.google.com/p/doclava/">Doclava</a>.
</div> <!-- end footer -->

</div> <!-- jd-content -->

</div><!-- end doc-content -->

</div> <!-- end body-content --> 

<script type="text/javascript">
init(); /* initialize doclava-developer-docs.js */
</script>

</body>
</html>
