<!DOCTYPE html>

















































<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <meta name="description" content="Javadoc API documentation for Insiteo API Documentation - Version 3.2.0_RC4." />

<link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.ico" />
<title>

  CatalogLRRDBHelper


| Insiteo API Documentation - Version 3.2.0_RC4

</title>
<link href="../../../../../../assets/doclava-developer-docs.css" rel="stylesheet" type="text/css" />
<link href="../../../../../../assets/customizations.css" rel="stylesheet" type="text/css" />
<script src="../../../../../../assets/search_autocomplete.js" type="text/javascript"></script>
<script src="../../../../../../assets/jquery-resizable.min.js" type="text/javascript"></script>
<script src="../../../../../../assets/doclava-developer-docs.js" type="text/javascript"></script>
<script src="../../../../../../assets/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  setToRoot("../../../../../", "../../../../../../assets/");
</script>
<script src="../../../../../../assets/doclava-developer-reference.js" type="text/javascript"></script>
<script src="../../../../../../assets/navtree_data.js" type="text/javascript"></script>
<script src="../../../../../../assets/customizations.js" type="text/javascript"></script>
<noscript>
  <style type="text/css">
    html,body{overflow:auto;}
    #body-content{position:relative; top:0;}
    #doc-content{overflow:visible;border-left:3px solid #666;}
    #side-nav{padding:0;}
    #side-nav .toggle-list ul {display:block;}
    #resize-packages-nav{border-bottom:3px solid #666;}
  </style>
</noscript>
</head>

<body class="">

<div id="header">
    <div id="headerLeft">
    
      <span id="masthead-title">Insiteo API Documentation - Version 3.2.0_RC4</span>
    
    </div>
    <div id="headerRight">
      
  <div id="search" >
      <div id="searchForm">
          <form accept-charset="utf-8" class="gsc-search-box" 
                onsubmit="return submit_search()">
            <table class="gsc-search-box" cellpadding="0" cellspacing="0"><tbody>
                <tr>
                  <td class="gsc-input">
                    <input id="search_autocomplete" class="gsc-input" type="text" size="33" autocomplete="off"
                      title="search developer docs" name="q"
                      value="search developer docs"
                      onFocus="search_focus_changed(this, true)"
                      onBlur="search_focus_changed(this, false)"
                      onkeydown="return search_changed(event, true, '../../../../../')"
                      onkeyup="return search_changed(event, false, '../../../../../')" />
                  <div id="search_filtered_div" class="no-display">
                      <table id="search_filtered" cellspacing=0>
                      </table>
                  </div>
                  </td>
                  <td class="gsc-search-button">
                    <input type="submit" value="Search" title="search" id="search-button" class="gsc-search-button" />
                  </td>
                  <td class="gsc-clear-button">
                    <div title="clear results" class="gsc-clear-button">&nbsp;</div>
                  </td>
                </tr></tbody>
              </table>
          </form>
      </div><!-- searchForm -->
  </div><!-- search -->
      
        
  <div id="api-level-toggle">
    <input type="checkbox" id="apiLevelCheckbox" onclick="toggleApiLevelSelector(this)" />
    <label for="apiLevelCheckbox" class="disabled">Filter by API Level: </label>
    <select id="apiLevelSelector">
      <!-- option elements added by buildApiLevelSelector() -->
    </select>
  </div>
  <script>
   var SINCE_DATA = [ 'v1', 'v1' ];
    
    var SINCE_LABELS = [ 'v1', 'v1' ];
    buildApiLevelSelector();
    addLoadEvent(changeApiLevel);
  </script>


      
    </div>
</div><!-- header -->


  <div class="g-section g-tpl-240" id="body-content">
    <div class="g-unit g-first side-nav-resizable" id="side-nav">
      <div id="swapper">
        <div id="nav-panels">
          <div id="resize-packages-nav">
            <div id="packages-nav">
              <div id="index-links">
                <a href="../../../../../packages.html"  >Package Index</a> | 
                <a href="../../../../../classes.html" >Class Index</a>
              </div>
              <ul>
                
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/analytics/package-summary.html">com.insiteo.lbs.analytics</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/analytics/entities/package-summary.html">com.insiteo.lbs.analytics.entities</a></li>
    <li class="selected api apilevel-">
  <a href="../../../../../com/insiteo/lbs/catalog/database/package-summary.html">com.insiteo.lbs.catalog.database</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/catalog/entities/package-summary.html">com.insiteo.lbs.catalog.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/catalog/render/package-summary.html">com.insiteo.lbs.catalog.render</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/common/package-summary.html">com.insiteo.lbs.common</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/common/auth/package-summary.html">com.insiteo.lbs.common.auth</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/common/auth/entities/package-summary.html">com.insiteo.lbs.common.auth.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/common/init/package-summary.html">com.insiteo.lbs.common.init</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/geofence/package-summary.html">com.insiteo.lbs.geofence</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/geofence/render/package-summary.html">com.insiteo.lbs.geofence.render</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/itinerary/package-summary.html">com.insiteo.lbs.itinerary</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/itinerary/entities/package-summary.html">com.insiteo.lbs.itinerary.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/location/package-summary.html">com.insiteo.lbs.location</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/location/utils/package-summary.html">com.insiteo.lbs.location.utils</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/package-summary.html">com.insiteo.lbs.map</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/database/package-summary.html">com.insiteo.lbs.map.database</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/entities/package-summary.html">com.insiteo.lbs.map.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/gestures/package-summary.html">com.insiteo.lbs.map.gestures</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/render/package-summary.html">com.insiteo.lbs.map.render</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/map/utils/package-summary.html">com.insiteo.lbs.map.utils</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/meetme/package-summary.html">com.insiteo.lbs.meetme</a></li>
    <li class="api apilevel-">
  <a href="../../../../../com/insiteo/lbs/meetme/requests/package-summary.html">com.insiteo.lbs.meetme.requests</a></li>
              </ul><br/>
            </div> <!-- end packages -->
          </div> <!-- end resize-packages -->
          <div id="classes-nav">
            <ul>
              
              
    <li><h2>Classes</h2>
      <ul>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/catalog/database/CatalogDBHelper.html">CatalogDBHelper</a></li>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/catalog/database/CatalogHRRDBHelper.html">CatalogHRRDBHelper</a></li>
          <li class="selected api apilevel-"><a href="../../../../../com/insiteo/lbs/catalog/database/CatalogLRRDBHelper.html">CatalogLRRDBHelper</a></li>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/catalog/database/CatalogLRRDBHelper.CategPoiAssoc.html">CatalogLRRDBHelper.CategPoiAssoc</a></li>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/catalog/database/CatalogLRRDBHelper.PoiPoiAssoc.html">CatalogLRRDBHelper.PoiPoiAssoc</a></li>
          <li class="api apilevel-"><a href="../../../../../com/insiteo/lbs/catalog/database/CatalogRWDBHelper.html">CatalogRWDBHelper</a></li>
      </ul>
    </li>
              
              
              
              
            </ul><br/>
          </div><!-- end classes -->
        </div><!-- end nav-panels -->
        <div id="nav-tree" style="display:none">
          <div id="index-links">
            <a href="../../../../../packages.html"  >Package Index</a> | 
            <a href="../../../../../classes.html" >Class Index</a>
          </div>
        </div><!-- end nav-tree -->
      </div><!-- end swapper -->
    </div> <!-- end side-nav -->
    <script>
      if (!isMobile) {
        $("<a href='#' id='nav-swap' onclick='swapNav();return false;' style='font-size:10px;line-height:9px;margin-left:1em;text-decoration:none;'><span id='tree-link'>Use Tree Navigation</span><span id='panel-link' style='display:none'>Use Panel Navigation</span></a>").appendTo("#side-nav");
        chooseDefaultNav();
        if ($("#nav-tree").is(':visible')) {
          init_default_navtree("../../../../../");
        } else {
          addLoadEvent(function() {
            scrollIntoView("packages-nav");
            scrollIntoView("classes-nav");
          });
        }
        $("#swapper").css({borderBottom:"2px solid #aaa"});
      } else {
        swapNav(); // tree view should be used on mobile
      }
    </script>



<div class="g-unit" id="doc-content">

<div id="api-info-block">




<div class="sum-details-links">

<div>
<a href="CatalogLRRDBHelper.html">View Documentation</a>
</div>


</div><!-- end sum-details-links -->
<div class="api-level">
  

  Since: <a href="../../../../../guide/appendix/api-levels.html#level">API Level </a>


  
  

</div>
</div><!-- end api-info-block -->


<!-- ======== START OF CLASS DATA ======== -->

<div id="jd-header">
    public
     
     
    
    class
<h1>CatalogLRRDBHelper</h1>



  
  
  


</div><!-- end header -->
<div id="jd-content">
  <pre class="prettyprint">
package com.insiteo.lbs.catalog.database;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.SQLException;

import com.insiteo.lbs.catalog.CatalogConstants;
import com.insiteo.lbs.catalog.entities.CatalogEntry;
import com.insiteo.lbs.catalog.entities.CatalogEntryType;
import com.insiteo.lbs.catalog.entities.Category;
import com.insiteo.lbs.catalog.entities.Media;
import com.insiteo.lbs.catalog.entities.Poi;
import com.insiteo.lbs.common.CommonConstants;
import com.insiteo.lbs.common.database.RWDBHelper;
import com.insiteo.lbs.common.init.EPackageType;
import com.insiteo.lbs.common.init.InitProvider;
import com.insiteo.lbs.common.utils.StringUtils;

public class CatalogLRRDBHelper extends RWDBHelper {

	// ==================================================================================================
	// Inner classes for associations
	// ==================================================================================================

	public class CategPoiAssoc {
		int poiId;
		int mCategId;
		int sortIndex;
		boolean isDynamic;
		String bitmapUrl;
		CatalogEntryType entryType;

		public CategPoiAssoc(int poiId, int aCategId, int sortIndex, String bitmapUrl, CatalogEntryType entryType) {
			this.poiId = poiId;
			this.mCategId = aCategId;
			this.sortIndex = sortIndex;
			this.bitmapUrl = bitmapUrl;
			this.entryType = entryType;
		}

		public CategPoiAssoc(int poiId, int aCategId, boolean aIsDynamic, int sortIndex) {
			this.poiId = poiId;
			this.mCategId = aCategId;
			isDynamic = aIsDynamic;
			this.sortIndex = sortIndex;
		}
	}

	public class PoiPoiAssoc {
		int poiId;
		int poiId2;
		boolean isPoi2Dynamic;

		public PoiPoiAssoc(int poiId, int poiId2, boolean isPoi2Dynamic) {
			this.poiId = poiId;
			this.poiId2 = poiId2;
			this.isPoi2Dynamic = isPoi2Dynamic;
		}
	}

	// ==================================================================================================
	// Singleton
	// ==================================================================================================	

	private static CatalogLRRDBHelper sInstance;

	public static CatalogLRRDBHelper getInstance() {
		if (sInstance == null) {
			sInstance = new CatalogLRRDBHelper();
			InitProvider.getInstance().registerDBHelper(sInstance, EPackageType.CONTENTLRR.getDirName());
		}
		return sInstance;
	}


	protected EPackageType mPackageType; 
	protected boolean mIsHrr;

	protected CatalogLRRDBHelper() {
		super();
		mPackageType = EPackageType.CONTENTLRR;
		setDBPath();
		mIsHrr = false;
	}

	@Override
	public void setDBPath() {
		mDBPath = InitProvider.getInstance().getDataDirPath() + "/" + mPackageType.getDirName() + "/" + CommonConstants.RO_DATABASE_FILE;
	}

	/**
	 * Returns the absolute path for the given bitmap
	 * @param aEntryType type of the entry to get path for 
	 * @param bitmapName the bitmap file name
	 * @return the absolute path for the given bitmap
	 */
	protected String getBitmapPath(CatalogEntryType aEntryType, String bitmapName) {
		if (bitmapName == null) {
			// If not bitmapName load the default image
			bitmapName = (aEntryType == CatalogEntryType.CATEGORY) ? getDefaultCategoryBitmap() : getDefaultPoiBitmap();
			return InitProvider.getInstance().getDataDirPath() + "/" + mPackageType.getDirName() + "/" + CatalogConstants.LOGOS_FOLDER + "/" 
			+ (aEntryType == CatalogEntryType.CATEGORY ? CatalogConstants.CATEG_FOLDER : CatalogConstants.POI_FOLDER) + "/"
			+ bitmapName;
		}
		else {
			return 	InitProvider.getInstance().getDataDirPath() + "/" + mPackageType.getDirName() + "/" + CatalogConstants.LOGOS_FOLDER + "/" 
					+ (aEntryType == CatalogEntryType.CATEGORY ? CatalogConstants.CATEG_FOLDER : CatalogConstants.POI_FOLDER) + "/"
					+ bitmapName;
		}
	}

	/**
	 * Returns the absolute path for the given square bitmap
	 * @param aEntryType type of the entry to get path for 
	 * @param bitmapName the bitmap file name
	 * @return the absolute path for the given bitmap
	 */
	protected String getSquareBitmapPath(CatalogEntryType aEntryType, String bitmapName) {
		if (bitmapName == null) {
			// If not bitmapName load the default image
			bitmapName = getDefaultPoiSquareBitmap();
			return InitProvider.getInstance().getDataDirPath() + "/" + mPackageType.getDirName() + "/" + CatalogConstants.LOGOS_FOLDER + "/" 
			+ (aEntryType == CatalogEntryType.CATEGORY ? CatalogConstants.CATEG_FOLDER : CatalogConstants.POI_FOLDER) + "/"
			+ bitmapName;
		}
		else {
			return 	InitProvider.getInstance().getDataDirPath() + "/" + mPackageType.getDirName() + "/" + CatalogConstants.LOGOS_FOLDER + "/" 
					+ (aEntryType == CatalogEntryType.CATEGORY ? CatalogConstants.CATEG_FOLDER : CatalogConstants.POI_FOLDER) + "/"
					+ bitmapName;
		}
	}

	/**
	 * @return true if the DBHelper is HRR
	 */
	protected boolean isHRR() {
		return mIsHrr;
	}

	// ==================================================================================================
	// Categories
	// ==================================================================================================

	protected static final String SQLITE_GET_CATEGORY_TYPE = "SELECT id FROM Category c, CategoryType ct WHERE c.id = ct.categId AND ct.type = ?";

	public ArrayList&lt;String&gt; getRootCategories() {
		final String request = "SELECT type FROM CategoryType";
		ArrayList&lt;String&gt; categs = null;
		Cursor cursor = null;

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.rawQuery(request, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor
		if ((cursor != null) &amp;&amp; cursor.moveToFirst()) {
			categs = new ArrayList&lt;String&gt;(cursor.getCount());
			do {
				categs.add(cursor.getString(0));
			} while (cursor.moveToNext());			
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return categs;
	}


	public Category getCategoryByType(String aCategoryType) {

		long time1 = System.currentTimeMillis();

		int categoryId = CommonConstants.NULL_ID;
		Cursor cursor = null;

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				String [] args = new String[]{aCategoryType};
				cursor = mDB.rawQuery(SQLITE_GET_CATEGORY_TYPE, args);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		long time2 = System.currentTimeMillis();

		//parse resulting cursor
		if ((cursor != null) &amp;&amp; cursor.moveToFirst()) {
			//get category id from request
			categoryId = cursor.getInt(0);
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return getCategory(categoryId);
	}	

	public Category getCategory(int aCategId) {
		return getCategory(aCategId, null, false, CommonConstants.NULL_ID, false);
	}

	public Category getCategory(int aCategId, String aTextFilter, boolean aSplitWords, int aPoiTypeID) {
		return getCategory(aCategId, aTextFilter, aSplitWords, aPoiTypeID, true);
	}

	private Category getCategory(int aCategId, String aTextFilter, boolean aSplitWords, int aPoiTypeID, boolean aUseFilters) {
		Category category = null;
		Cursor cursor = null;

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.query("Category", null, "id="+aCategId, null, null, null, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor, and fill the category
		if ((cursor != null) &amp;&amp; cursor.moveToFirst()) {
			category = CatalogDataCreator.createCategory(this, cursor);
			//set sub entries
			if (aUseFilters) {
				category.setSubEntries(getEntries(aCategId, aTextFilter, aSplitWords, aPoiTypeID));
			}
			else {
				category.setSubEntries(getEntries(aCategId));
			}
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return category;
	}

	public List&lt;Category&gt; getCategoryWithWhereClause(String whereClause){
		List&lt;Category&gt; categories = new ArrayList&lt;Category&gt;();
		Cursor cursor = null;

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.query("Category", null, whereClause, null, null, null, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		if (cursor != null &amp;&amp; cursor.moveToFirst()) {
			Category category = null;
			do {
				category = CatalogDataCreator.createCategory(this, cursor);
				if (category != null) {
					category.setSubEntries(getEntries(category.getId()));
					categories.add(category);
				}
			} while(cursor.moveToNext());
		}
		
		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return categories;
	}

	// ==================================================================================================
	// Entries
	// ==================================================================================================

	private static final String SQLITE_GET_CATEG_ENTRIES_FOR_CATEGORY = 
			"SELECT id AS idEntry, dispLabel AS nameEntry, bitmapName AS imageUrlEntry, dispDescription AS subtitleEntry, sortIndex AS sortIndex, " +
					"extra1, extra2, extra3, fExtra1, dispExtra1, dispExtra2, dispExtra3, dispFExtra1 " +
					"FROM Category WHERE parentCategory = ?";

	private static final String SQLITE_GET_POI_ENTRIES_FOR_CATEGORY = 
			"SELECT p.id AS idEntry, p.extId AS extIdEntry, p.dispName AS nameEntry, p.squareBitmapName AS imageUrlEntry, p.dispSubtitle AS subtitleEntry, cp.sortIndex AS sortIndex, " +
					"p.extra1, p.extra2, p.extra3, p.fExtra1, p.dispExtra1, p.dispExtra2, p.dispExtra3, p.dispFExtra1 " +
					"FROM Poi p, CategoryPoi cp WHERE cp.categId = ? AND cp.poiId = p.id";

	private static final String SQLITE_GET_SPONSOR_ENTRIES_FOR_CATEGORY = 
			"SELECT p.id AS idEntry, p.dispName AS nameEntry, p.squareBitmapName AS imageUrlEntry, p.dispSubtitle AS subtitleEntry, s.sortIndex AS sortIndex, " +
					"p.extra1, p.extra2, p.extra3, p.fExtra1, p.dispExtra1, p.dispExtra2, p.dispExtra3, p.dispFExtra1 " +
					"FROM Poi p, Sponsor s WHERE s.categId = ? AND s.poiId = p.id";

	private static final String SQLITE_GET_POI_ENTRIES_BY_IDS = 
			"SELECT p.id AS idEntry, p.extId AS extIdEntry, p.dispName AS nameEntry, p.squareBitmapName AS imageUrlEntry, p.dispSubtitle AS subtitleEntry, p.sortIndex AS sortIndex, " +
					"p.extra1, p.extra2, p.extra3, p.fExtra1, p.dispExtra1, p.dispExtra2, p.dispExtra3, p.dispFExtra1 " +
					"FROM Poi p WHERE p.id IN ?";


	public ArrayList&lt;CatalogEntry&gt; getEntries(int aCategId) {
		ArrayList&lt;CatalogEntry&gt; entries = null;		
		ArrayList&lt;CatalogEntry&gt; entriesCateg = getEntries(aCategId, CatalogEntryType.CATEGORY, SQLITE_GET_CATEG_ENTRIES_FOR_CATEGORY);
		ArrayList&lt;CatalogEntry&gt; entriesPoi = getEntries(aCategId, CatalogEntryType.POI, SQLITE_GET_POI_ENTRIES_FOR_CATEGORY);
		ArrayList&lt;CatalogEntry&gt; entriesSponsor = getEntries(aCategId, CatalogEntryType.SPONSOR, SQLITE_GET_SPONSOR_ENTRIES_FOR_CATEGORY);

		//concatenate results
		entries = new ArrayList&lt;CatalogEntry&gt;(entriesCateg.size() + entriesPoi.size() + entriesSponsor.size());
		entries.addAll(entriesCateg);
		entries.addAll(entriesPoi);
		entries.addAll(entriesSponsor);

		return entries;
	}

	protected ArrayList&lt;CatalogEntry&gt; getEntries(int aCategId, String aTextFilter, boolean aSplitWords, int aPoiTypeID) {
		//build keywords string for request
		String categWhereClause = "? AND Category MATCH ('";
		String poiWhereClause = "? AND Poi MATCH ('";
		String[] keywords = new String[]{aTextFilter};
		if (aSplitWords) {
			keywords = aTextFilter.replace("'", "''").split(" ");
		}
		boolean first = true;
		for (String word : keywords) {
			if (!first) {
				categWhereClause += " OR ";
				poiWhereClause += " OR ";
			}
			categWhereClause += word + "*";
			poiWhereClause += word + "*";
			first = false;
		}
		categWhereClause += "')";
		poiWhereClause += "')";

		//add clause for poi type ID
		if (aPoiTypeID != CommonConstants.NULL_ID) {
			poiWhereClause += " AND p.typeId = " + aPoiTypeID;
		}

		ArrayList&lt;CatalogEntry&gt; entries = null;		
		ArrayList&lt;CatalogEntry&gt; entriesCateg = getEntries(aCategId, CatalogEntryType.CATEGORY, SQLITE_GET_CATEG_ENTRIES_FOR_CATEGORY.replace("?", categWhereClause));
		ArrayList&lt;CatalogEntry&gt; entriesPoi = getEntries(aCategId, CatalogEntryType.POI, SQLITE_GET_POI_ENTRIES_FOR_CATEGORY.replace("?", poiWhereClause));
		ArrayList&lt;CatalogEntry&gt; entriesSponsor = getEntries(aCategId, CatalogEntryType.SPONSOR, SQLITE_GET_SPONSOR_ENTRIES_FOR_CATEGORY.replace("?", poiWhereClause));

		//concatenate results
		entries = new ArrayList&lt;CatalogEntry&gt;(entriesCateg.size() + entriesPoi.size() + entriesSponsor.size());
		entries.addAll(entriesCateg);
		entries.addAll(entriesPoi);
		entries.addAll(entriesSponsor);

		return entries;
	}

	private ArrayList&lt;CatalogEntry&gt; getEntries(int aCategId, CatalogEntryType aEntryType, String aRequest) {
		ArrayList&lt;CatalogEntry&gt; entries = new ArrayList&lt;CatalogEntry&gt;(0);
		Cursor cursor = null;

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.rawQuery(aRequest.replace("?", ""+aCategId), null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor, and fill the entries lists
		if (cursor != null) {
			entries = CatalogDataCreator.createCatalogEntries(this, cursor, aEntryType);
		}

		//close cursor
		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return entries;
	}

	/**
	 * Get entries from Poi table
	 * @param aEntryType the type of entries (Sponsor or Poi)
	 * @param aPoiAssocs a list of CategPoi assoc, all of the same type (cf. aEntryType)
	 * @return a list of CatalogEntries containing all pois found for the ids in aPoiAssocs 
	 */
	protected ArrayList&lt;CatalogEntry&gt; getPoiEntries(CatalogEntryType aEntryType, ArrayList&lt;CategPoiAssoc&gt; aPoiAssocs) {
		return getPoiEntries(aEntryType, aPoiAssocs, null, false, CommonConstants.NULL_ID, false);
	}

	protected ArrayList&lt;CatalogEntry&gt; getPoiEntries(CatalogEntryType aEntryType, ArrayList&lt;CategPoiAssoc&gt; aPoiAssocs, String aTextFilter, boolean aSplitWords, int aPoiTypeID) {
		return getPoiEntries(aEntryType, aPoiAssocs, aTextFilter, aSplitWords, aPoiTypeID, true);
	}

	private ArrayList&lt;CatalogEntry&gt; getPoiEntries(CatalogEntryType aEntryType, ArrayList&lt;CategPoiAssoc&gt; aPoiAssocs, String aTextFilter, boolean aSplitWords, int aPoiTypeID, boolean aUseFilters) {
		//create poi IDs table 
		int[] poiIds = new int[aPoiAssocs.size()];
		int i = 0;
		for (CategPoiAssoc assoc : aPoiAssocs) {
			poiIds[i++] = assoc.poiId;
		}		

		ArrayList&lt;CatalogEntry&gt; entries = null;
		if (aUseFilters) {
			entries = getPoiEntries(aEntryType, poiIds, aTextFilter, aSplitWords, aPoiTypeID);
		}
		else {
			entries = getPoiEntries(aEntryType, poiIds);
		}

		//override sortIndex and imageUrl in result entries
		for (CatalogEntry entry : entries) {
			for (CategPoiAssoc assoc : aPoiAssocs) {
				if (entry.getId() == assoc.poiId) {
					entry.setSortIndex(assoc.sortIndex);
					if (assoc.entryType == CatalogEntryType.SPONSOR) {
						entry.setImageUrl(assoc.bitmapUrl);
					}
					break;
				}
			}
		}

		return entries;
	}

	/**
	 * Get entries from Poi table
	 * @param aEntryType the type of entries (Sponsor or Poi)
	 * @param aPoiIDs an array of poi IDs to get
	 * @return a list of CatalogEntries containing all pois found for the ids in aPoiIDs 
	 */
	protected ArrayList&lt;CatalogEntry&gt; getPoiEntries(CatalogEntryType aEntryType, int[] aPoiIDs) {
		return getPoiEntries(aEntryType, aPoiIDs, SQLITE_GET_POI_ENTRIES_BY_IDS);
	}

	protected ArrayList&lt;CatalogEntry&gt; getPoiEntries(CatalogEntryType aEntryType, int[] aPoiIDs, String aTextFilter, boolean aSplitWords, int aPoiTypeID) {
		//build keywords string for request
		String poiWhereClause = "? AND Poi MATCH ('";
		String[] keywords = new String[]{aTextFilter};
		if (aSplitWords) {
			keywords = aTextFilter.replace("'", "''").split(" ");
		}
		boolean first = true;
		for (String word : keywords) {
			if (!first) {
				poiWhereClause += " OR ";
			}
			poiWhereClause += word + "*";
			first = false;
		}
		poiWhereClause += "')";

		//add clause for poi type ID
		if (aPoiTypeID != CommonConstants.NULL_ID) {
			poiWhereClause += " AND p.typeId = " + aPoiTypeID;
		}

		return getPoiEntries(aEntryType, aPoiIDs, SQLITE_GET_POI_ENTRIES_BY_IDS.replace("?", poiWhereClause));
	}

	private ArrayList&lt;CatalogEntry&gt; getPoiEntries(CatalogEntryType aEntryType, int[] aPoiIDs, String aRequest) {
		ArrayList&lt;CatalogEntry&gt; entries = new ArrayList&lt;CatalogEntry&gt;(0);
		Cursor cursor = null;

		//agregate poi IDs for IN clause
		String poiIds = "(";
		boolean first = true;
		for (int poiId : aPoiIDs) {
			if (!first) {
				poiIds += ",";
			}
			poiIds += poiId;
			first = false;
		}		
		poiIds += ")";

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.rawQuery(aRequest.replace("?", poiIds), null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor, and fill the entries lists
		if (cursor != null) {
			entries = CatalogDataCreator.createCatalogEntries(this, cursor, aEntryType);
		}

		//close cursor
		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return entries;
	}

	/**
	 * Retrieves all the ids of the categories that are linked to this Poi
	 * @param aPoiId the id of the Poi
	 * @return
	 */
	public List&lt;Integer&gt; getCategoriesAssociatedToPoi(int aPoiId){
		ArrayList&lt;Integer&gt; categoryIds = new ArrayList&lt;Integer&gt;();
		Cursor cursor = null;

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				String sqlRequest = "SELECT * FROM CategoryPoi WHERE poiId = ?";
				String [] args = new String[]{aPoiId + ""};
				cursor = mDB.rawQuery(sqlRequest, args);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		if (cursor != null &amp;&amp; cursor.moveToFirst()) {
			int colCategoryId = cursor.getColumnIndexOrThrow("categId");
			do {
				int categoryId = cursor.getInt(colCategoryId);
				categoryIds.add(categoryId);
			} while (cursor.moveToNext());
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return categoryIds;
	}

	// ==================================================================================================
	// Pois
	// ==================================================================================================

	private static final String SQLITE_GET_MEDIAS = "SELECT * FROM Media m, MediaPoi mp WHERE mp.poiId = ? AND mp.mediaId = m.id";
	private static final String SQLITE_GET_REFER_POI = "SELECT * FROM PoiRefer WHERE poiId = ?";

	public Poi getPoi(String whereClause) {
		Poi poi = null;
		Cursor cursor = null;
		if (whereClause == null) {
			whereClause = "";
		}

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				String request = "SELECT * FROM Poi " + whereClause;
				cursor = mDB.rawQuery(request, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor, and fill the entry list
		if ((cursor != null) &amp;&amp; cursor.moveToFirst()) {
			poi = CatalogDataCreator.createPoi(this, cursor);
			poi.setMedias(getMedias(poi.getId()));	//set poi medias
			poi.setRefPoiId(getReferPois(poi.getId()));	//set referent pois
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return poi;
	} 

	protected int[] getPoiRefCount(int[] aPoiIds, int aPoiTypeID) {
		int[] poiRefsCount = new int[aPoiIds.length]; 
		for (int i=0 ; i&lt;poiRefsCount.length ; i++) {
			poiRefsCount[i] = 0;
		}
		Cursor cursor = null;		

		//build ids string for request
		String strPoiIds = "";
		for (int id : aPoiIds) {
			strPoiIds += id + ",";
		}
		//remove last ','
		if (aPoiIds.length &gt; 0) {
			strPoiIds = strPoiIds.substring(0, strPoiIds.length()-1);
		}

		String poiTypeArg = "";
		if (aPoiTypeID != CommonConstants.NULL_ID) {
			poiTypeArg += " AND pr.poiTypeId2=" + aPoiTypeID;
		}
		String request = "SELECT pr.poiId, COUNT(pr.poiId2) AS poiCount FROM PoiRefer pr INNER JOIN Poi p ON pr.poiId2=p.id WHERE pr.poiId IN (" + strPoiIds + ")" + poiTypeArg + " GROUP BY pr.poiId";

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.rawQuery(request, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor, and fill the ref ids table
		if (cursor != null &amp;&amp; cursor.moveToFirst()) {
			int colPoiId = cursor.getColumnIndexOrThrow("poiId");
			int colPoiCount = cursor.getColumnIndexOrThrow("poiCount");
			do {
				int poiId = cursor.getInt(colPoiId);
				int poiCount = cursor.getInt(colPoiCount);

				for (int i=0 ; i&lt;aPoiIds.length ; i++) {
					if (aPoiIds[i] == poiId) {
						poiRefsCount[i] = poiCount;
						break;
					}
				}

			} while (cursor.moveToNext());
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return poiRefsCount;
	}

	public ArrayList&lt;Poi&gt; getPoisByTypeID(Integer aTypeID) {
		String whereClause = null;
		if (aTypeID != null) {
			whereClause = "typeId="+aTypeID;
		}
		return getPois(whereClause);
	}


	public ArrayList&lt;Poi&gt; getPois(int[] aPoiIds) {
		//build ids string for request
		String strIds = "";
		for (int id : aPoiIds) {
			strIds += id + ",";
		}
		//remove last ','
		if (aPoiIds.length &gt; 0) {
			strIds = strIds.substring(0, strIds.length()-1);
		}

		String whereArgs = "id IN (" + strIds + ")";

		return getPois(whereArgs);
	}

	private ArrayList&lt;Poi&gt; getPois(String whereArgs) {
		ArrayList&lt;Poi&gt; pois = null;
		Cursor cursor = null;

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.query("Poi", null, whereArgs, null, null, null, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor, and fill the entry list
		if (cursor != null) {
			pois = CatalogDataCreator.createPois(this, cursor);
			//set medias for each poi
			for (Poi poi : pois) {
				poi.setMedias(getMedias(poi.getId()));
				poi.setRefPoiId(getReferPois(poi.getId()));
			}
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return pois;
	}

	public ArrayList&lt;Media&gt; getMedias(int aPoiId) {
		ArrayList&lt;Media&gt; medias = new ArrayList&lt;Media&gt;(0);
		Cursor cursor = null;

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.rawQuery(SQLITE_GET_MEDIAS.replace("?", ""+aPoiId), null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor
		if (cursor != null) {
			medias = CatalogDataCreator.createMedias(cursor);
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return medias;
	}

	public int[] getReferPois(int aPoiId) {
		int[] refPois = null;
		Cursor cursor = null;


		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.rawQuery(SQLITE_GET_REFER_POI.replace("?", ""+aPoiId), null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor
		if (cursor != null &amp;&amp; cursor.moveToFirst()) {
			refPois = new int[cursor.getCount()];
			int colId = cursor.getColumnIndexOrThrow("poiId2");
			int i = 0;
			do {
				refPois[i++] = cursor.getInt(colId);				
			} while (cursor.moveToNext());
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return refPois;
	}

	public List&lt;Poi&gt; getPoiWithWhereClause(String whereClause){
		List&lt;Poi&gt; pois = null;
		Cursor cursor = null;

		if (whereClause == null) {
			whereClause = "";
		}

		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.rawQuery("SELECT * FROM Poi " + whereClause, null);
			}
			
			
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor
		if (cursor != null &amp;&amp; cursor.moveToFirst()) {
			pois = CatalogDataCreator.createPois(this, cursor);
			//set medias for each poi
			for (Poi poi : pois) {
				poi.setMedias(getMedias(poi.getId()));
				poi.setRefPoiId(getReferPois(poi.getId()));
			}
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return pois;
	}

	/**
	 * Methods that updates the values that are stored for a Category in the database
	 * @param aCategory
	 * @return
	 */
	public boolean updatePoi(Poi aPoi){
		ContentValues row = new ContentValues();
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {

				row.put("dispExtra1", aPoi.getDispExtra1());
				row.put("dispExtra2", aPoi.getDispExtra2());
				row.put("dispExtra3", aPoi.getDispExtra3());
				row.put("dispName", aPoi.getName());
				row.put("dispDescription", aPoi.getDescription());
				row.put("dispPhone", aPoi.getPhoneNumber());

				String whereClause = "id" + " = ? ";
				String[] whereArgs = new String[]{aPoi.getId() + ""};

				int affectedRows = mDB.update("Poi", row, whereClause, whereArgs);

				if(affectedRows == -1)
					return false;
			}
		} catch(SQLException e){
			e.printStackTrace();
			return false;
		} catch (InterruptedException e) {
			e.printStackTrace();
			return false;
		}
		finally {
			unlock();
		}

		return true;
	}
	// ==================================================================================================
	// Search
	// ==================================================================================================

	private static final String SEARCH_LIKE_CLAUSE_TAG = "${likeclause}";

	private static final String SQLITE_SEARCH_CATEGORY_ENTRIES_NO_FTS = "SELECT id AS idEntry, dispLabel AS nameEntry, bitmapName AS imageUrlEntry, dispDescription AS subtitleEntry, sortIndex AS sortIndex, " +
			"extra1, extra2, extra3, fExtra1, dispExtra1, dispExtra2, dispExtra3, dispFExtra1 " +
			"FROM Category WHERE (" + SEARCH_LIKE_CLAUSE_TAG + ") GROUP BY dispLabel ORDER BY sortIndex, dispLabel ASC";

	private static final String SQLITE_SEARCH_POIS_ENTRIES_NO_FTS = "SELECT c.id AS idEntry, c.dispLabel AS nameEntry, c.bitmapName AS imageUrlEntry, c.dispDescription AS subtitleEntry, " +
			"COUNT(cp.poiId) as countPoi, c.sortIndex FROM Category c, CategoryPoi cp, Poi p WHERE (" + SEARCH_LIKE_CLAUSE_TAG + ") AND " +
			"cp.categId = c.id AND p.id = cp.poiId GROUP BY nameEntry ORDER BY countPoi DESC, c.sortIndex ASC, c.dispLabel ASC;";

	private static final String SQLITE_GET_CATEGORY_SEARCH_ENTRIES = 
			"SELECT id AS idEntry, dispLabel AS nameEntry, bitmapName AS imageUrlEntry, dispDescription AS subtitleEntry, sortIndex AS sortIndex, " +
					"extra1, extra2, extra3, fExtra1, dispExtra1, dispExtra2, dispExtra3, dispFExtra1 " +
					"FROM Category";

	private static final String SQLITE_GET_POI_SEARCH_ENTRIES = 
			"SELECT DISTINCT p.id AS idEntry, p.dispName AS nameEntry, p.squareBitmapName AS imageUrlEntry, p.dispSubtitle AS subtitleEntry, p.sortIndex AS sortIndex, " +
					"extra1, extra2, extra3, fExtra1, dispExtra1, dispExtra2, dispExtra3, dispFExtra1 " +
					"FROM Poi p, CategoryPoi cp";

	/**
	 * Method called to execute a text search and get all related Pois with a specific type id.
	 * @param aSearchedText The text searched in database fields.
	 * @param aSplitWords if false, the searchedText parameter is used as a unique string. If true we split this string in several words (space separated)
	 * @param aPoiTypeID A poi type used to filter the results. Set it to &lt;code&gt;CommonConstants.NULL_ID&lt;/code&gt; if not needed.
	 * @return All the concerned pois.
	 */
	public ArrayList&lt;Poi&gt; searchPois(String aSearchedText, boolean aSplitWords, int aPoiTypeID) {
		ArrayList&lt;Poi&gt; pois = new ArrayList&lt;Poi&gt;(0);
		Cursor cursorPoi = null;

		//build keywords string for request
		String whereClause = " dispName MATCH ('";
		String[] keywords = new String[]{aSearchedText};
		if (aSplitWords) {
			keywords = aSearchedText.replace("'", "''").split(" ");
		}
		boolean first = true;
		for (String word : keywords) {
			if (!first) {
				whereClause += " OR ";
			}
			whereClause += word + "*";
			first = false;
		}
		whereClause += "')";

		//add clause for poi type ID
		if (aPoiTypeID != CommonConstants.NULL_ID) {
			whereClause += " AND Poi.typeId = " + aPoiTypeID;
		}

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				//				String test = mDB.query("Poi", null, whereClause, null, null, null, null).toString();
				cursorPoi = mDB.query("Poi", null, whereClause, null, null, null, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor
		if (cursorPoi != null) {
			pois = CatalogDataCreator.createPois(this, cursorPoi); 
			//set medias for each poi
			for (Poi poi : pois) {
				poi.setMedias(getMedias(poi.getId()));
				poi.setRefPoiId(getReferPois(poi.getId()));
			}
		}

		//close cursor
		if (cursorPoi != null &amp;&amp; !cursorPoi.isClosed()) {
			cursorPoi.close();
		}

		return pois;
	}

	/**
	 * Method called to execute a text search and get all related Pois with a specific type id.
	 * @param aSearchedText The text searched in database fields.
	 * @param aSplitWords if false, the searchedText parameter is used as a unique string. If true we split this string in several words (space separated)
	 * @param aPoiTypeID A poi type used to filter the results. Set it to &lt;code&gt;CommonConstants.NULL_ID&lt;/code&gt; if not needed.
	 * @param aLimit the limit of returned results
	 * @return All the concerned pois.
	 */
	public ArrayList&lt;Poi&gt; searchPois(String aSearchedText, boolean aSplitWords, int aPoiTypeID, int aLimit) {
		ArrayList&lt;Poi&gt; pois = new ArrayList&lt;Poi&gt;(0);
		Cursor cursorPoi = null;

		//build keywords string for request
		String whereClause = " Poi MATCH ('";
		String[] keywords = new String[]{aSearchedText};
		if (aSplitWords) {
			keywords = aSearchedText.replace("'", "''").split(" ");
		}
		boolean first = true;
		for (String word : keywords) {
			if (!first) {
				whereClause += " OR ";
			}
			whereClause += word + "*";
			first = false;
		}
		whereClause += "')";

		//add clause for poi type ID
		if (aPoiTypeID != CommonConstants.NULL_ID) {
			whereClause += " AND Poi.typeId = " + aPoiTypeID;
		}

		// add limit clause
		String limitClause = "";
		if (aLimit &gt; 0) {
			limitClause = String.valueOf(aLimit);
		}
		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				//				String test = mDB.query("Poi", null, whereClause, null, null, null, null).toString();
				cursorPoi = mDB.query("Poi", null, whereClause, null, null, null, null, limitClause);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor
		if (cursorPoi != null) {
			pois = CatalogDataCreator.createPois(this, cursorPoi); 
			//set medias for each poi
			for (Poi poi : pois) {
				poi.setMedias(getMedias(poi.getId()));
				poi.setRefPoiId(getReferPois(poi.getId()));
			}
		}

		//close cursor
		if (cursorPoi != null &amp;&amp; !cursorPoi.isClosed()) {
			cursorPoi.close();
		}

		return pois;
	}

	/**
	 * Method called to execute a text search and get all related entries (Category and Poi). 
	 * @param aSearchedText The text searched in database fields.
	 * @param aSplitWords if false, the searchedText parameter is used as a unique string. If true we split this string in several words (space separated)
	 * @param aPoiTypeID  A poi type used to filter the results. Set it to &lt;code&gt;CommonConstants.NULL_ID&lt;/code&gt; if not needed.
	 * @return All the concerned entries.
	 */
	public ArrayList&lt;CatalogEntry&gt; searchEntries(String aSearchedText, boolean aSplitWords, int aPoiTypeID) {
		ArrayList&lt;CatalogEntry&gt; entries = null;
		ArrayList&lt;CatalogEntry&gt; entriesCateg = new ArrayList&lt;CatalogEntry&gt;(0);
		ArrayList&lt;CatalogEntry&gt; entriesPoi = new ArrayList&lt;CatalogEntry&gt;(0);
		Cursor cursorCateg = null;
		Cursor cursorPoi = null;

		//build keywords string for request
		String categWhereClause = " WHERE Category MATCH ('";
		String poiWhereClause = " WHERE Poi MATCH ('";
		String[] keywords = new String[]{aSearchedText};
		if (aSplitWords) {
			keywords = aSearchedText.replace("'", "''").split(" ");
		}
		boolean first = true;
		for (String word : keywords) {
			if (!first) {
				categWhereClause += " OR ";
				poiWhereClause += " OR ";
			}
			categWhereClause += word + "*";
			poiWhereClause += word + "*";
			first = false;
		}
		categWhereClause += "')";
		poiWhereClause += "')";

		//add clause for poi type ID
		if (aPoiTypeID != CommonConstants.NULL_ID) {
			poiWhereClause += " AND Poi.typeId = " + aPoiTypeID;
		}

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursorCateg = mDB.rawQuery(SQLITE_GET_CATEGORY_SEARCH_ENTRIES + categWhereClause, null);
				cursorPoi = mDB.rawQuery(SQLITE_GET_POI_SEARCH_ENTRIES + poiWhereClause, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursors
		if (cursorCateg != null) {
			entriesCateg = CatalogDataCreator.createCatalogEntries(this, cursorCateg, CatalogEntryType.CATEGORY); 
		}
		if (cursorPoi != null) {
			entriesPoi = CatalogDataCreator.createCatalogEntries(this, cursorPoi, CatalogEntryType.POI); 
		}

		//close cursors
		if (cursorCateg != null &amp;&amp; !cursorCateg.isClosed()) {
			cursorCateg.close();
		}
		if (cursorPoi != null &amp;&amp; !cursorPoi.isClosed()) {
			cursorPoi.close();
		}

		//concatenate results
		entries = new ArrayList&lt;CatalogEntry&gt;(entriesCateg.size() + entriesPoi.size());
		entries.addAll(entriesCateg);
		entries.addAll(entriesPoi);

		return entries;
	}

	/**
	 * Method called to execute a text search and get all related entries (Category and Poi). 
	 * @param aSearchedText The text searched in database fields.
	 * @param aSplitWords if false, the searchedText parameter is used as a unique string. If true we split this string in several words (space separated)
	 * @param aPoiTypeID  A poi type used to filter the results. Set it to &lt;code&gt;CommonConstants.NULL_ID&lt;/code&gt; if not needed.
	 * @param aCategoryColumns the columns in the category table to search for. If null the request will be done on all columns.
	 * @param aPoiColumns the columns in the poi table to search for. If null the request will be done on all columns.
	 * @return
	 */
	public ArrayList&lt;CatalogEntry&gt; searchEntries(String aSearchedText, boolean aSplitWords, int aPoiTypeID, String[] aCategoryColumns, String[] aPoiColumns) {
		ArrayList&lt;CatalogEntry&gt; entries = null;
		ArrayList&lt;CatalogEntry&gt; entriesCateg = new ArrayList&lt;CatalogEntry&gt;(0);
		ArrayList&lt;CatalogEntry&gt; entriesPoi = new ArrayList&lt;CatalogEntry&gt;(0);
		Cursor cursorCateg = null;
		Cursor cursorPoi = null;

		//build keywords string for request
		String categWhereClause = " WHERE Category MATCH ('";
		String poiWhereClause = " WHERE Poi MATCH ('";
		String[] keywords = new String[]{aSearchedText};
		if (aSplitWords) {
			keywords = aSearchedText.replace("'", "''").split("\\s+");
		}
		boolean first = true;
		for (String word : keywords) {
			if (!first) {
				categWhereClause += " OR ";
				poiWhereClause += " OR ";
			}

			if (aCategoryColumns != null) {
				for (int i = 0; i &lt; aCategoryColumns.length; i++) {
					categWhereClause += aCategoryColumns[i] + ":" +word + "*";
					if (i != aCategoryColumns.length-1) {
						categWhereClause += " OR ";
					}
				}
			} else {
				categWhereClause += word + "*";
			}

			if (aPoiColumns != null) {
				for (int i = 0; i &lt; aPoiColumns.length; i++) {
					poiWhereClause += aPoiColumns[i] + ":" +word + "*";
					if (i != aPoiColumns.length-1) {
						poiWhereClause += " OR ";
					}
				}
			} else {
				poiWhereClause += word + "*";
			}
			first = false;
		}
		categWhereClause += "')";
		poiWhereClause += "')";


		//add clause for poi type ID
		if (aPoiTypeID != CommonConstants.NULL_ID) {
			poiWhereClause += " AND p.typeId = " + aPoiTypeID;
		}

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursorCateg = mDB.rawQuery(SQLITE_GET_CATEGORY_SEARCH_ENTRIES + categWhereClause, null);
				cursorPoi = mDB.rawQuery(SQLITE_GET_POI_SEARCH_ENTRIES + poiWhereClause, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursors
		if (cursorCateg != null) {
			entriesCateg = CatalogDataCreator.createCatalogEntries(this, cursorCateg, CatalogEntryType.CATEGORY); 
		}
		if (cursorPoi != null) {
			entriesPoi = CatalogDataCreator.createCatalogEntries(this, cursorPoi, CatalogEntryType.POI); 
		}

		//close cursors
		if (cursorCateg != null &amp;&amp; !cursorCateg.isClosed()) {
			cursorCateg.close();
		}
		if (cursorPoi != null &amp;&amp; !cursorPoi.isClosed()) {
			cursorPoi.close();
		}

		//concatenate results
		entries = new ArrayList&lt;CatalogEntry&gt;(entriesCateg.size() + entriesPoi.size());
		entries.addAll(entriesCateg);
		entries.addAll(entriesPoi);



		return entries;
	}

	/**
	 * Method to perform search queries when the Database is not using FTS. The result are sorted according to their sortIndex and then their dispLabel.
	 * @param aSearchedText
	 * @param aPoiTypeID
	 * @param aCategory
	 * @return
	 */
	public ArrayList&lt;CatalogEntry&gt; searchCategoryEntriesNoFTS(final String aSearchedText){

		ArrayList&lt;CatalogEntry&gt; resultCategs = new ArrayList&lt;CatalogEntry&gt;(0);
		Cursor cursorCateg = null;

		//build keywords string for request
		int i = 0;
		String categLikeClause = "";

		String[] keywords = aSearchedText.replace("'", "''").split(" ");
		for (String word : keywords) {
			if (i == 0) {
				categLikeClause += "(";
			}
			else {
				categLikeClause += " AND ";
			}
			categLikeClause += "dispLabel LIKE \"%%" + word + "%%\"";
			i++;
		}

		categLikeClause += ")";

		//		//add param for categ request
		String categWhereClause = "";

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				String sqlQuery = SQLITE_SEARCH_CATEGORY_ENTRIES_NO_FTS.replace(SEARCH_LIKE_CLAUSE_TAG, categLikeClause + categWhereClause);
				cursorCateg = mDB.rawQuery(sqlQuery, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		if (cursorCateg != null) {
			resultCategs = CatalogDataCreator.createCatalogEntries(this, cursorCateg, CatalogEntryType.CATEGORY);
		}

		if (cursorCateg != null &amp;&amp; !cursorCateg.isClosed()) {
			cursorCateg.close();
		}

		return resultCategs;
	}

	/**
	 * Method to perform search queries when the Database is not using FTS. The result are sorted according to their sortIndex and then their dispLabel.
	 * @param aSearchedText
	 * @param aPoiTypeID
	 * @param aCategory
	 * @return
	 */
	public ArrayList&lt;CatalogEntry&gt; searchEntriesNoFTS(final String aSearchedText, int aPoiTypeID){

		ArrayList&lt;CatalogEntry&gt; entries = null;
		List&lt;CatalogEntry&gt; entriesCateg = new ArrayList&lt;CatalogEntry&gt;(0);
		List&lt;CatalogEntry&gt; entriesPoi = new ArrayList&lt;CatalogEntry&gt;(0);
		Cursor cursorCateg = null;
		Cursor cursorPoi = null;

		//build keywords string for request
		int i = 0;

		String requestLikeClause = "";
		String poiLikeClause = "";
		String[] keywords = aSearchedText.replace("'", "''").split(" ");
		for (String word : keywords) {
			if (i == 0) {
				requestLikeClause += "(";
				poiLikeClause += "(";
			}
			else {
				requestLikeClause += " AND ";
				poiLikeClause += " AND ";
			}
			requestLikeClause += "dispLabel LIKE \"%%" + word + "%%\"";
			poiLikeClause += "dispName LIKE \"%%" + word + "%%\"";
			i++;
		}
		requestLikeClause += ")";
		poiLikeClause += ")";



		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				String sqlQuery = SQLITE_SEARCH_CATEGORY_ENTRIES_NO_FTS.replace(SEARCH_LIKE_CLAUSE_TAG, requestLikeClause);
				cursorCateg = mDB.rawQuery(sqlQuery, null);
				sqlQuery = SQLITE_SEARCH_POIS_ENTRIES_NO_FTS.replace(SEARCH_LIKE_CLAUSE_TAG, poiLikeClause);
				cursorPoi = mDB.rawQuery(sqlQuery, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//		//parse resulting cursors
		if (cursorCateg != null) {
			entriesCateg = CatalogDataCreator.createCatalogEntries(this, cursorCateg, CatalogEntryType.CATEGORY); 
		}
		if (cursorPoi != null) {
			entriesPoi = CatalogDataCreator.createCatalogEntries(this, cursorPoi, CatalogEntryType.CATEGORY); 
		}

		//		//close cursors
		if (cursorCateg != null &amp;&amp; !cursorCateg.isClosed()) {
			cursorCateg.close();
		}
		if (cursorPoi != null &amp;&amp; !cursorPoi.isClosed()) {
			cursorPoi.close();
		}

		//		//concatenate results
		entries = new ArrayList&lt;CatalogEntry&gt;(entriesCateg.size() + entriesPoi.size());
		entries.addAll(entriesCateg);

		final String aNormalizedSearchText = aSearchedText.trim();

		Collections.sort(entries, new Comparator&lt;CatalogEntry&gt;() {
			@Override
			public int compare(final CatalogEntry object1, final CatalogEntry object2) {

				int dist1 = StringUtils.calculateLevenshteinDistance(aNormalizedSearchText, StringUtils.normalize(object1.getName()));
				int dist2 = StringUtils.calculateLevenshteinDistance(aNormalizedSearchText, StringUtils.normalize(object2.getName())); 


				if(dist1 &lt; dist2){
					return -1;
				} else {
					return 1;
				}
			}
		});

		List&lt;CatalogEntry&gt; toAdd = new ArrayList&lt;CatalogEntry&gt;();

		for(CatalogEntry entry : entriesPoi){
			boolean add = true;
			for(CatalogEntry e : entries){
				if (e.getName().equals(entry.getName())) {
					add = false;
					break;
				}
			}
			if(add){
				toAdd.add(entry);
			}
		}

		entries.addAll(toAdd);



		return entries;
	}


	/**
	 * Methods that return the list of CategPoiAssoc that fill the given clause 
	 * @param aRequest
	 * @return
	 */
	public ArrayList&lt;CategPoiAssoc&gt; getCategoryPoiAssoc(String aClause){

		Cursor cursor = null;
		ArrayList&lt;CategPoiAssoc&gt; result = new ArrayList&lt;CategPoiAssoc&gt;(0);

		// The COUNT is used to have the more represented categories first

		String BASE_REQUEST = "SELECT cp.poiId, cp.categId, cp.isDynamicPoi, COUNT(cp.poiId) as countPoi, cp.sortIndex FROM CategoryPoi cp, Poi p WHERE " 
				+ SEARCH_LIKE_CLAUSE_TAG + " p.id = cp.poiId GROUP BY cp.categId ORDER BY countPoi DESC, cp.sortIndex ASC";

		if (!aClause.equals("")) {
			aClause = aClause + " AND ";
		}

		String request = BASE_REQUEST.replace(SEARCH_LIKE_CLAUSE_TAG, aClause);

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.rawQuery(request, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		if (cursor != null) {			

			int colPoiId = cursor.getColumnIndexOrThrow("poiId");
			int colCategId = cursor.getColumnIndexOrThrow("categId");
			int colIsDynamic = cursor.getColumnIndexOrThrow("isDynamicPoi");
			int colSortIndex = cursor.getColumnIndexOrThrow("sortIndex");

			if(cursor.moveToFirst()){
				do {
					int poiId = cursor.getInt(colPoiId);
					int categId = cursor.getInt(colCategId);
					boolean isDynamic = cursor.getInt(colIsDynamic) == 1;
					int sortIndex = cursor.getInt(colSortIndex);
					result.add(new CategPoiAssoc(poiId, categId, isDynamic, sortIndex));
				} while (cursor.moveToNext());
			}

			cursor.close();
		}

		return result;
	}

	private String getDefaultPoiBitmap(){
		Cursor cursor = null;
		String bitmap = "";

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				String request = "SELECT defaultPoiBitmapName FROM Site ";
				cursor = mDB.rawQuery(request, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor, and fill the entry list
		if ((cursor != null) &amp;&amp; cursor.moveToFirst()) {
			int colId = cursor.getColumnIndexOrThrow("defaultPoiBitmapName");
			bitmap = cursor.getString(colId);
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return bitmap;
	}

	private String getDefaultPoiSquareBitmap(){
		Cursor cursor = null;
		String bitmap = "";

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				String request = "SELECT defaultPoiSquareBitmapName FROM Site ";
				cursor = mDB.rawQuery(request, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor, and fill the entry list
		if ((cursor != null) &amp;&amp; cursor.moveToFirst()) {
			int colId = cursor.getColumnIndexOrThrow("defaultPoiSquareBitmapName");
			bitmap = cursor.getString(colId);
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return bitmap;
	}

	private String getDefaultCategoryBitmap(){
		Cursor cursor = null;
		String bitmap = "";

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				String request = "SELECT defaultCategBitmapName FROM Site ";
				cursor = mDB.rawQuery(request, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		//parse resulting cursor, and fill the entry list
		if ((cursor != null) &amp;&amp; cursor.moveToFirst()) {
			int colId = cursor.getColumnIndexOrThrow("defaultCategBitmapName");
			bitmap = cursor.getString(colId);
		}

		if (cursor != null &amp;&amp; !cursor.isClosed()) {
			cursor.close();
		}

		return bitmap;
	}


	// ==================================================================================================
	// Catalog Entries
	// ==================================================================================================

	public ArrayList&lt;CatalogEntry&gt; getCatalogEntriesById(CatalogEntryType aType, int[] aIds){

		String request = "";
		ArrayList&lt;CatalogEntry&gt; entries = new ArrayList&lt;CatalogEntry&gt;();
		String inStatement = " id IN (";
		Cursor cursor = null;

		for (int i = 0; i &lt; aIds.length; i++) {
			if (i != aIds.length - 1) {
				inStatement = inStatement + aIds[i] + ", ";
			} else {
				inStatement = inStatement + aIds[i];
			}
		}

		inStatement = inStatement + ")";

		if (aType == CatalogEntryType.CATEGORY) {
			request = "SELECT id AS idEntry, dispLabel AS nameEntry, bitmapName AS imageUrlEntry, dispDescription AS subtitleEntry, sortIndex AS sortIndex, " +
					"extra1, extra2, extra3, fExtra1, dispExtra1, dispExtra2, dispExtra3, dispFExtra1 " +
					"FROM Category WHERE " + inStatement ;
		} else if (aType == CatalogEntryType.POI) {

		}

		//request database
		try {
			lock();
			if ((mDB != null) &amp;&amp; mDB.isOpen()) {
				cursor = mDB.rawQuery(request, null);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finally {
			unlock();
		}

		if (cursor != null) {
			entries = CatalogDataCreator.createCatalogEntries(this, cursor, CatalogEntryType.CATEGORY); 
		}

		return entries;
	}
}

  </pre>
</div>
<div id="footer">
Generated by <a href="http://code.google.com/p/doclava/">Doclava</a>.
</div> <!-- end footer -->

</div> <!-- jd-content -->

</div><!-- end doc-content -->

</div> <!-- end body-content --> 

<script type="text/javascript">
init(); /* initialize doclava-developer-docs.js */
</script>

</body>
</html>
