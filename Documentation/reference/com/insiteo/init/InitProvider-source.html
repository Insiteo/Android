<!DOCTYPE html>

















































<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <meta name="description" content="Javadoc API documentation for Insiteo API Documentation - Version 3.2." />

<link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico" />
<title>

  InitProvider


| Insiteo API Documentation - Version 3.2

</title>
<link href="../../../../assets/doclava-developer-docs.css" rel="stylesheet" type="text/css" />
<link href="../../../../assets/customizations.css" rel="stylesheet" type="text/css" />
<script src="../../../../assets/search_autocomplete.js" type="text/javascript"></script>
<script src="../../../../assets/jquery-resizable.min.js" type="text/javascript"></script>
<script src="../../../../assets/doclava-developer-docs.js" type="text/javascript"></script>
<script src="../../../../assets/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  setToRoot("../../../", "../../../../assets/");
</script>
<script src="../../../../assets/doclava-developer-reference.js" type="text/javascript"></script>
<script src="../../../../assets/navtree_data.js" type="text/javascript"></script>
<script src="../../../../assets/customizations.js" type="text/javascript"></script>
<noscript>
  <style type="text/css">
    html,body{overflow:auto;}
    #body-content{position:relative; top:0;}
    #doc-content{overflow:visible;border-left:3px solid #666;}
    #side-nav{padding:0;}
    #side-nav .toggle-list ul {display:block;}
    #resize-packages-nav{border-bottom:3px solid #666;}
  </style>
</noscript>
</head>

<body class="">

<div id="header">
    <div id="headerLeft">
    
      <span id="masthead-title">Insiteo API Documentation - Version 3.2</span>
    
    </div>
    <div id="headerRight">
      
  <div id="search" >
      <div id="searchForm">
          <form accept-charset="utf-8" class="gsc-search-box" 
                onsubmit="return submit_search()">
            <table class="gsc-search-box" cellpadding="0" cellspacing="0"><tbody>
                <tr>
                  <td class="gsc-input">
                    <input id="search_autocomplete" class="gsc-input" type="text" size="33" autocomplete="off"
                      title="search developer docs" name="q"
                      value="search developer docs"
                      onFocus="search_focus_changed(this, true)"
                      onBlur="search_focus_changed(this, false)"
                      onkeydown="return search_changed(event, true, '../../../')"
                      onkeyup="return search_changed(event, false, '../../../')" />
                  <div id="search_filtered_div" class="no-display">
                      <table id="search_filtered" cellspacing=0>
                      </table>
                  </div>
                  </td>
                  <td class="gsc-search-button">
                    <input type="submit" value="Search" title="search" id="search-button" class="gsc-search-button" />
                  </td>
                  <td class="gsc-clear-button">
                    <div title="clear results" class="gsc-clear-button">&nbsp;</div>
                  </td>
                </tr></tbody>
              </table>
          </form>
      </div><!-- searchForm -->
  </div><!-- search -->
      
        
  <div id="api-level-toggle">
    <input type="checkbox" id="apiLevelCheckbox" onclick="toggleApiLevelSelector(this)" />
    <label for="apiLevelCheckbox" class="disabled">Filter by API Level: </label>
    <select id="apiLevelSelector">
      <!-- option elements added by buildApiLevelSelector() -->
    </select>
  </div>
  <script>
   var SINCE_DATA = [ 'v1', 'v1' ];
    
    var SINCE_LABELS = [ 'v1', 'v1' ];
    buildApiLevelSelector();
    addLoadEvent(changeApiLevel);
  </script>


      
    </div>
</div><!-- header -->


  <div class="g-section g-tpl-240" id="body-content">
    <div class="g-unit g-first side-nav-resizable" id="side-nav">
      <div id="swapper">
        <div id="nav-panels">
          <div id="resize-packages-nav">
            <div id="packages-nav">
              <div id="index-links">
                <a href="../../../packages.html"  >Package Index</a> | 
                <a href="../../../classes.html" >Class Index</a>
              </div>
              <ul>
                
    <li class="api apilevel-">
  <a href="../../../com/insiteo/analytics/package-summary.html">com.insiteo.analytics</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/analytics/entities/package-summary.html">com.insiteo.analytics.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/common/package-summary.html">com.insiteo.common</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/common/rendertouch/package-summary.html">com.insiteo.common.rendertouch</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/common/utils/geom/package-summary.html">com.insiteo.common.utils.geom</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/common/utils/threading/package-summary.html">com.insiteo.common.utils.threading</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/geofence/package-summary.html">com.insiteo.geofence</a></li>
    <li class="selected api apilevel-">
  <a href="../../../com/insiteo/init/package-summary.html">com.insiteo.init</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/itinerary/package-summary.html">com.insiteo.itinerary</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/itinerary/entities/package-summary.html">com.insiteo.itinerary.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/location/package-summary.html">com.insiteo.location</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/location/utils/package-summary.html">com.insiteo.location.utils</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/map/package-summary.html">com.insiteo.map</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/map/database/package-summary.html">com.insiteo.map.database</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/map/entities/package-summary.html">com.insiteo.map.entities</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/map/render/package-summary.html">com.insiteo.map.render</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/map/utils/package-summary.html">com.insiteo.map.utils</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/meetme/package-summary.html">com.insiteo.meetme</a></li>
    <li class="api apilevel-">
  <a href="../../../com/insiteo/meetme/requests/package-summary.html">com.insiteo.meetme.requests</a></li>
              </ul><br/>
            </div> <!-- end packages -->
          </div> <!-- end resize-packages -->
          <div id="classes-nav">
            <ul>
              
    <li><h2>Interfaces</h2>
      <ul>
          <li class="api apilevel-"><a href="../../../com/insiteo/init/IInitListener.html">IInitListener</a></li>
      </ul>
    </li>
              
    <li><h2>Classes</h2>
      <ul>
          <li class="selected api apilevel-"><a href="../../../com/insiteo/init/InitProvider.html">InitProvider</a></li>
          <li class="api apilevel-"><a href="../../../com/insiteo/init/PackageDescriptor.html">PackageDescriptor</a></li>
      </ul>
    </li>
              
              
    <li><h2>Enums</h2>
      <ul>
          <li class="api apilevel-"><a href="../../../com/insiteo/init/EInitResult.html">EInitResult</a></li>
          <li class="api apilevel-"><a href="../../../com/insiteo/init/EPackageType.html">EPackageType</a></li>
          <li class="api apilevel-"><a href="../../../com/insiteo/init/InitProvider.Server.html">InitProvider.Server</a></li>
      </ul>
    </li>
              
              
            </ul><br/>
          </div><!-- end classes -->
        </div><!-- end nav-panels -->
        <div id="nav-tree" style="display:none">
          <div id="index-links">
            <a href="../../../packages.html"  >Package Index</a> | 
            <a href="../../../classes.html" >Class Index</a>
          </div>
        </div><!-- end nav-tree -->
      </div><!-- end swapper -->
    </div> <!-- end side-nav -->
    <script>
      if (!isMobile) {
        $("<a href='#' id='nav-swap' onclick='swapNav();return false;' style='font-size:10px;line-height:9px;margin-left:1em;text-decoration:none;'><span id='tree-link'>Use Tree Navigation</span><span id='panel-link' style='display:none'>Use Panel Navigation</span></a>").appendTo("#side-nav");
        chooseDefaultNav();
        if ($("#nav-tree").is(':visible')) {
          init_default_navtree("../../../");
        } else {
          addLoadEvent(function() {
            scrollIntoView("packages-nav");
            scrollIntoView("classes-nav");
          });
        }
        $("#swapper").css({borderBottom:"2px solid #aaa"});
      } else {
        swapNav(); // tree view should be used on mobile
      }
    </script>



<div class="g-unit" id="doc-content">

<div id="api-info-block">



  
   
  
  
  
  

  
   
  
  
  
  


<div class="sum-details-links">

<div>
<a href="InitProvider.html">View Documentation</a>
</div>


</div><!-- end sum-details-links -->
<div class="api-level">
  

  Since: <a href="../../../guide/appendix/api-levels.html#level">API Level </a>


  
  

</div>
</div><!-- end api-info-block -->


<!-- ======== START OF CLASS DATA ======== -->

<div id="jd-header">
    public
     
     
    
    class
<h1>InitProvider</h1>



  
    extends <a href="http://d.android.com/reference/java/lang/Object.html">Object</a><br/>
  
  
  

  
  
      implements 
      
        <a href="../../../com/insiteo/init/IInitListener.html">IInitListener</a> 
      
  
  


</div><!-- end header -->
<div id="jd-content">
  <pre class="prettyprint">
package com.insiteo.init;

import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.Stack;

import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Environment;
import android.os.PowerManager;
import android.os.SystemClock;
import android.util.SparseArray;

import com.insiteo.analytics.AnalyticsManager;
import com.insiteo.common.CommonConstants;
import com.insiteo.common.IMapData;
import com.insiteo.common.IMapRepository;
import com.insiteo.common.IZone;
import com.insiteo.common.InsiteoError;
import com.insiteo.common.R;
import com.insiteo.common.database.RODBHelper;
import com.insiteo.common.net.comm.ProtoLoader;
import com.insiteo.common.utils.FileUtils;
import com.insiteo.common.utils.Log;
import com.insiteo.common.utils.threading.ICancelable;

/**
 * Singleton that handles initialization of Insiteo API.
 * It will store useful information such as data version, or URLs for requests.
 * Be sure to call {@link #initAPI(Activity, IInitListener, PackageDescriptor, boolean, boolean, String, int, int, String) init} before using other insiteo modules.
 */
public class InitProvider implements IMapRepository, IInitListener {	

	private static final String TAG = "INSITEO_API_COMMON_INIT_PROVIDER";
	
	private long mLastDataUpdateTime = 0;
	private long mLastInitTime = 0;

	/** lock to avoid phone to go into sleep mode */ 
	private PowerManager.WakeLock mWakeLock;

	private String mInitUrl = null;
	private int mSiteId = CommonConstants.NULL_ID;
	private String mLang = null;
	private int mAppVersion = CommonConstants.NULL_VERSION;

	private String mContentUrl = null;
	private String mMapsUrl = null;
	private String mLbsUrl = null;
	private String mAnalyticsUrl = null;

	private Context mApplicationContext = null;
	private boolean mAnalyticsAutoStart = false;

	private Stack&lt;PackageDescriptor&gt; mPackagesAvailable;
	private Stack&lt;PackageDescriptor&gt; mPackagesToUpdate;
	private Stack&lt;PackageDescriptor&gt; mPackagesDownloaded;


	private String mExternalStoragePath = null;
	private String mRODataDirPath = null;
	private String mRWDataDirPath = null;
	private InsiteoError mError = null;
	private volatile boolean mIsInitialised = false;
	private static InitProvider sInstance = null;

	private WeakReference&lt;IInitListener&gt; mListener = null;
	private WeakReference&lt;Activity&gt; mContext = null;

	private SparseArray&lt;? extends IZone&gt; mZones = null; 
	private SparseArray&lt;? extends IMapData&gt; mMaps = null;
	private int mMapRootID;

	private HashMap&lt;String, RODBHelper&gt; mDBHelpers = null;


	/**
	 * Defines the server used. By default it is set to Server.PROD
	 */
	private Server mServer = Server.PROD;

	/**
	 * This enum is used to defined the type of server used. Files downloaded will be store in a specific
	 * directory depending on this value.
	 */
	public enum Server{
		/**
		 * Files will be stored under the 'dev' directory.
		 */
		DEV,
		/**
		 * Files will be stored under the 'test' directory.
		 */
		TEST,
		/**
		 * Files will be stored under the 'release' directory.
		 */
		PROD
	}


	public Context getApplicationContext(){
		return mApplicationContext;
	}
	/**
	 * private constructor
	 */
	private InitProvider() {
		mZones = new SparseArray&lt;IZone&gt;(0); 
		mMaps = new SparseArray&lt;IMapData&gt;(0);
		mListener = new WeakReference&lt;IInitListener&gt;(null);
		//		mDBHelpers = new LinkedList&lt;RODBHelper&gt;();
		mDBHelpers = new HashMap&lt;String, RODBHelper&gt;();
	}

	/**
	 * Get InitProvider instance
	 * @return the InitProvider unique instance
	 */
	public static InitProvider getInstance() {
		if (sInstance == null) {
			sInstance = new InitProvider();
		}
		return sInstance;
	}


	//******************************************************************************************************************
	// API AUTHENTICATION
	// *****************************************************************************************************************

	/**
	 * Sets the Insiteo authentication API Key that was provided when you registered to our services. 
	 * This key is required in order to start the API.
	 * @param key
	 */
	public void setAPIKey(String key){
		CommonConstants.API_KEY = key;
	}


	//******************************************************************************************************************
	// API INITIALIZATION
	// *****************************************************************************************************************	
	
	/**
	 * Equivalent to {@link #startAPI(Activity, IInitListener, PackageDescriptor, boolean, boolean, String, int, int, String)} with a null masterpackage, the PROD server and analytics OFF by default.
	 */
	public ICancelable startAPI(final Activity aContext, final IInitListener aListener, String aInitUrl, int aSiteId, int aAppVersion, String aLang) {
		return startAPI(aContext, aListener, null, false, false, aInitUrl, aSiteId, aAppVersion, aLang, Server.PROD, true);
	}

	/**
	 * Equivalent to {@link #startAPI(Activity, IInitListener, PackageDescriptor, boolean, boolean, String, int, int, String)} with a null masterpackage and the PROD server by default
	 */
	public ICancelable startAPI(final Activity aContext, final IInitListener aListener, String aInitUrl, int aSiteId, int aAppVersion, String aLang, Server aServer, boolean aAnalyticsAutoStart) {
		return startAPI(aContext, aListener, null, false, false, aInitUrl, aSiteId, aAppVersion, aLang, aServer, aAnalyticsAutoStart);
	}

	/**
	 * Equivalent to {@link #startAPI(Activity, IInitListener, PackageDescriptor, boolean, boolean, String, int, int, String)} with the PROD server by default.
	 */
	public ICancelable startAPI(final Activity aContext, final IInitListener aListener,
			final PackageDescriptor aMasterPackage, final boolean aMasterPackageInAssets, final boolean aForceMasterPackage, 
			String aInitUrl, int aSiteId, int aAppVersion, String aLang) {
		return startAPI(aContext, aListener, aMasterPackage, aMasterPackageInAssets, aForceMasterPackage, aInitUrl, aSiteId, aAppVersion, aLang, Server.PROD, true);
	}

	/**
	 * Request for API initialization. This is an asynchronous call : results will be send via aListener's callbacks. This method will return an ICancelable that allow you to stop the background init task. 
	 * @param aContext the context in which init will be done
	 * @param aListener the listener that will receive init notifications. The listener is stored as a &lt;code&gt;WeakReference&lt;/code&gt; : be careful to keep a reference on it in your code if you want to receive notifications. 
	 * @param aMasterPackage a PackageDescriptor for a zip file containing data for insiteo modules : type should be &lt;code&gt;FULL&lt;/code&gt;, url is the path of the zip file, md5 is the md5 sum of the zip file, version and size are not used. If null, data will be downloaded only when needed.
	 * @param aMasterPackageInAssets if true, zip file will be loaded from assets, otherwise it will be loaded as a regular file. aMasterPackage.getUrl() will be used to know the file path.
	 * @param aForceMasterPackage if true, master package will be deployed on sdcard, even if it is already deployed
	 * @param aInitUrl the url of the init request
	 * @param aSiteId the site ID of the calling application
	 * @param aAppVersion the application code version of the calling application
	 * @param aLang the locale of the calling application 
	 * @param aServer the server the application is used on
	 * @return an ICancelable object, representing the init task that is running background. Call &lt;code&gt;cancel()&lt;/code&gt; on it to stop the init task (before you kill aContext for example).
	 */
	public ICancelable startAPI(final Activity aContext, final IInitListener aListener,
			final PackageDescriptor aMasterPackage, final boolean aMasterPackageInAssets, final boolean aForceMasterPackage, 
			String aInitUrl, int aSiteId, int aAppVersion, String aLang, Server aServer, boolean aAnalyticsAutoStart) {
		
		mLastInitTime = System.currentTimeMillis();
		
		mListener = new WeakReference&lt;IInitListener&gt;(aListener);
		mContext = new WeakReference&lt;Activity&gt;(aContext);
		mApplicationContext = aContext.getApplicationContext();
		mSiteId = aSiteId;
		mLang = aLang;
		mAppVersion = aAppVersion;
		mInitUrl = aInitUrl;
		mServer = aServer;

		mAnalyticsAutoStart = aAnalyticsAutoStart;

		//start async work
		InitTask initTask = new InitTask(this, aMasterPackage, aMasterPackageInAssets, aForceMasterPackage);
		Thread t = new Thread(initTask);
		t.start();

		// Stop analytics API if it was started
		if (AnalyticsManager.getInstance().isStarted()) {
			AnalyticsManager.getInstance().stop();
		}


		return initTask;
	}

	//******************************************************************************************************************
	// PACKAGES UPDATE
	// *****************************************************************************************************************


	/**
	 * Update all data for insiteo modules. This method will download and install packages containing all available data for the site defined at init. 
	 * Download and install are running asynchronously : aListener will be notified of progress.
	 * @param aContext the context in which this task will run.
	 * @param aListener the listener that will receive progress notification. If null, you won't receive notification.
	 * @param aForceUpdate if false, only the new packages will be installed ; if true all packages will be downloaded and installed, even if they are already deployed
	 * @return an ICancelable object. Call cancel() on this ICancelable to abort this update (no notification will be sent after cancel).
	 */
	public ICancelable updatePackages(Activity aContext, IInitListener aListener, boolean aForceUpdate) {

		if (aForceUpdate) {
			return updatePackages(aContext, aListener, mPackagesAvailable);
		} else {
			return updatePackages(aContext, aListener, mPackagesToUpdate);
		}
	}

	/**
	 * Update all data for insiteo modules. This method will download and install only the mist of selected packages containing all available data for the site defined at init. 
	 * Download and install are running asynchronously : aListener will be notified of progress.
	 * @param aContext the context in which this task will run.
	 * @param aListener the listener that will receive progress notification. If null, you won't receive notification.
	 * @return an ICancelable object. Call cancel() on this ICancelable to abort this update (no notification will be sent after cancel).
	 */
	public ICancelable updatePackages(Activity aContext, IInitListener aListener, Stack&lt;PackageDescriptor&gt; aPackagesToUpdate) {
		mListener = new WeakReference&lt;IInitListener&gt;(aListener);
		PackageUpdater pu = new PackageUpdater(aContext, this);

		mPackagesDownloaded = aPackagesToUpdate;

		//close all DBHelpers to avoid problems while moving/deleting files
		closeDBHelpers(false);

		// Stop analytics API if it was started
		if (AnalyticsManager.getInstance().isStarted()) {
			AnalyticsManager.getInstance().stop();
		}

		if (aPackagesToUpdate != null) {
			pu.updatePackages((Stack&lt;PackageDescriptor&gt;) aPackagesToUpdate.clone(), mRODataDirPath);
		} else {
			// Launch the update process even if the package list is null to notify on update done
			pu.updatePackages(null, mRODataDirPath);
		}


		return pu;
	}

	private void notifyInitDone(EInitResult aInitRes) {
		//close then re-open dbhelpers
		closeDBHelpers(true);
		initDBHelpers();

		//notify lister if any
		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onInitDone(aInitRes, mError);
		}

		//release powermanager wakelock
		if (mWakeLock.isHeld()) {
			mWakeLock.release();
		}
	}

	// ==================================================================================================
	// DB repository
	// ==================================================================================================	

	/**
	 * @hide
	 * Application should not use this method directly.
	 * Register a database helper and tries to open it directly. The InitProvider will handle the open/close of those DBHelper
	 * when updating data.
	 * @param aDBHelper the DB helper to register
	 * @param aName The name that will be used to store the database.
	 * @return true if the database is opened
	 */
	public boolean registerDBHelper(RODBHelper aDBHelper, String aName) {
		boolean isOpened = false;
		isOpened = aDBHelper.open();
		mDBHelpers.put(aName, aDBHelper);
		return isOpened;

	}

	//get path to insiteo read-only data
	private String initDataDirPath() {
		String path;
		switch (mServer) {
		case TEST:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "test" + "/" + mSiteId + "/" + mAppVersion + "/" + mLang;
			break;
		case DEV:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "dev" + "/" + mSiteId + "/" + mAppVersion + "/" + mLang;
			break;
		default:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "release" + "/" + mSiteId + "/" + mAppVersion + "/" + mLang;
			break;
		}
		return path;
	}

	//get path to insiteo read-write data
	private String initRWDataDirPath() {
		String path = "";
		Context context = mContext.get();

		if (context != null) {
			File f = context.getDir(CommonConstants.DATA_DIRECTORY, Context.MODE_PRIVATE);
			if (f != null) {
				path = f.getAbsolutePath() + "/" + mSiteId;
				f = new File(path);
				f.mkdirs();
			}
		}


		return path;
	}

	//open all DBHelpers. Do it in reverse order, thus adding in mDBHelpers does not need mutex.
	private void initDBHelpers() {
		Set&lt;String&gt; keys = mDBHelpers.keySet();
		Iterator&lt;String&gt; dbIter = keys.iterator();

		while (dbIter.hasNext()) {
			String key = dbIter.next();
			RODBHelper dbHelper = mDBHelpers.get(key);
			dbHelper.setDBPath();
			dbHelper.open();
		}
	}

	//open all DBHelpers. 
	/**
	 * Closes all the DBHelpers. This is call when the application's data are being downloaded or updated.
	 * This process only closes the database that belong to the EPackageTypes that are being downloaded.
	 * Do it in reverse order.
	 * @param forceClose if set to true all the databases will be closed ow only the one from the package being modified
	 */
	private void closeDBHelpers(boolean forceClose) {
		Set&lt;String&gt; keys = mDBHelpers.keySet();
		Iterator&lt;String&gt; dbIter = keys.iterator();

		while (dbIter.hasNext()) {
			String key = dbIter.next();

			if (forceClose) {
				RODBHelper dbHelper = mDBHelpers.get(key);
				dbHelper.close();
			} else {
				if (mPackagesDownloaded != null) {
					for (int i = 0; i &lt; mPackagesDownloaded.size(); i++) {
						if (mPackagesDownloaded.get(i).getType().getDirName().equals(key)) {
							RODBHelper dbHelper = mDBHelpers.get(key);
							dbHelper.close();
						}
					}
				}	
			}




		}
	}

	// ==================================================================================================
	// IInitListener callbacks
	// ==================================================================================================	

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onInstallProgress(long aCurrentFile, long aTotalFiles) {
		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onInstallProgress(aCurrentFile, aTotalFiles);
		}
	}

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onDataUpdateDone(boolean aSuccess, InsiteoError aError) {
		
		Log.d(TAG, "onDataUpdateDone");
		
		//open databases
		initDBHelpers();

		mLastDataUpdateTime = SystemClock.elapsedRealtime();

		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onDataUpdateDone(aSuccess, aError);
		}

		initializeAnalytics();


	}

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onInitDone(EInitResult aResult, InsiteoError aError) {
		//this will never be called
	}

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onDownloadProgress(long aDownloadedBytes, long aTotalBytes) {
		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onDownloadProgress(aDownloadedBytes, aTotalBytes);
		}
	}

	/**
	 * @hide
	 * This method is used by internal process : it must not be called by application
	 */
	@Override
	public void onPackageDowloadBegin(EPackageType aPkgType) {
		IInitListener listener = mListener.get(); 
		if (listener != null) {
			listener.onPackageDowloadBegin(aPkgType);
		}		
	}
	// ==================================================================================================
	// Map Repository
	// ==================================================================================================	

	@Override
	public IMapData getMapRoot() {
		return mMaps.get(mMapRootID);
	}

	@Override
	public IMapData getMap(int id) {
		return mMaps.get(id);
	}

	@Override
	public SparseArray&lt;? extends IMapData&gt; getMaps() {
		return mMaps;
	}

	@Override
	public IZone getZone(int aZoneID) {
		return mZones.get(aZoneID);
	}

	@Override
	public void setMapRoot(int aMapRootID) {
		mMapRootID = aMapRootID;
	}

	@Override
	public void setMaps(SparseArray&lt;? extends IMapData&gt; aMaps) {
		if (aMaps != null) {
			mMaps = aMaps;
		}
	}

	@Override
	public void setZones(SparseArray&lt;? extends IZone&gt; aZones) {
		if (aZones != null) {
			mZones = aZones;
		}
	}

	public List&lt;IMapData&gt; getSortedMaps(){
		List&lt;IMapData&gt; result = new ArrayList&lt;IMapData&gt;();

		for (int i = 0; i &lt; mMaps.size(); i++) {
			result.add(mMaps.valueAt(i));
		}

		Collections.sort(result, new Comparator&lt;IMapData&gt;() {
			@Override
			public int compare(final IMapData object1, final IMapData object2) {
				int result;
				if(object1.getSortIndex() &lt; object2.getSortIndex()){
					result = -1;
				} else if (object1.getSortIndex()  ==  object2.getSortIndex()) {
					result = 0;
				} else {
					result = 1;
				}
				return result;
			}
		} );
		return result;
	}

	@Override
	public SparseArray&lt;? extends IZone&gt; getZones() {
		return mZones;
	}
	// ==================================================================================================
	// ACCESSORS
	// ==================================================================================================	

	/**
	 * Set the default language in shared prefs
	 * @param aDefaultLanguage the default language for the current site 
	 */
	/* package */ void setDefaultLanguage(String aDefaultLanguage) {
		Context context = mContext.get();
		if (context != null) {
			SharedPreferences prefs = context.getSharedPreferences(CommonConstants.PREFERENCES_BUNDLE_NAME, Context.MODE_PRIVATE);
			Editor edit = prefs.edit();
			if (aDefaultLanguage != null) {
				edit.putString(CommonConstants.PREF_DEFAULT_LANGUAGE, aDefaultLanguage);
				edit.commit();
			}
		}
	}

	/**
	 * Get the default language stored in shared prefs
	 * @return the default language if defined, null otherwise.
	 */
	/* package */ String getDefaultLanguage() {
		String lang = null;
		Context context = mContext.get();
		if (context != null) {
			SharedPreferences prefs = context.getSharedPreferences(CommonConstants.PREFERENCES_BUNDLE_NAME, Context.MODE_PRIVATE);
			lang = prefs.getString(CommonConstants.PREF_DEFAULT_LANGUAGE, null);
		}
		return lang;
	}	

	/**
	 * Set a flag indicating that a master package is deployed
	 * @param aPackageMD5 the MD5 sum of the deployed package. Passing null indicates that no package is deployed
	 */
	/* package */ void setMasterPackageDeployed(String aPackageMD5) {
		Context context = mContext.get();
		if (context != null) {
			SharedPreferences prefs = context.getSharedPreferences(CommonConstants.PREFERENCES_BUNDLE_NAME, Context.MODE_PRIVATE);
			Editor edit = prefs.edit();
			if (aPackageMD5 == null) {
				edit.remove(CommonConstants.PREF_FULL_PACK_DEPLOYED);
			}
			else {
				edit.putString(CommonConstants.PREF_FULL_PACK_DEPLOYED, aPackageMD5);
			}
			edit.commit();
		}
	}

	/**
	 * Check if a master package is already deployed
	 * @param aPackageMD5 the MD5 sum of the package to test
	 * @return true if a package with the given MD5 sum is already deployed, false otherwise
	 */
	public boolean hasMasterPackage(String aPackageMD5) {
		boolean result = false;
		Context context = mContext.get();
		if (context != null) {
			SharedPreferences prefs = context.getSharedPreferences(CommonConstants.PREFERENCES_BUNDLE_NAME, Context.MODE_PRIVATE);
			String currentMD5 = prefs.getString(CommonConstants.PREF_FULL_PACK_DEPLOYED, null);
			if (currentMD5 != null &amp;&amp; currentMD5.equals(aPackageMD5)) {
				result = true;
			}
		}
		return result;
	}	

	/**
	 * Check if a master package is already deployed
	 * @return true if a package is already deployed, false otherwise
	 */
	public boolean hasMasterPackage() {
		boolean result = false;
		Context context = mContext.get();
		if (context != null) {
			SharedPreferences prefs = context.getSharedPreferences(CommonConstants.PREFERENCES_BUNDLE_NAME, Context.MODE_PRIVATE);
			String currentMD5 = prefs.getString(CommonConstants.PREF_FULL_PACK_DEPLOYED, null);
			if (currentMD5 != null) {
				result = true;
			}
		}
		return result;
	}

	/**
	 * Check if a package of the given type is already deployed
	 * @param aType the type of package to check
	 * @return true if a package of the given type is already deployed, false otherwise
	 */
	public boolean hasPackage(EPackageType aType) {
		boolean result = false;
		File f = new File(mRODataDirPath + "/" + aType.getDirName() + "/" + CommonConstants.VERSION_FILENAME);
		if (f != null &amp;&amp; f.exists()) {
			result = true;
		}
		return result;
	}

	/**
	 * Get the time of the last package deployment (gotten through SystemClock.elapsedRealTime)
	 * @return the time of last data update (in millisecond), or 0 if no data update was done
	 */
	public long getLastDataUpdateTime() {
		return mLastDataUpdateTime;
	}

	/**
	 * @return true if the InitProvider is initialized
	 */
	public boolean isInitialized()  {
		return mIsInitialised;
	}
	/**
	 * Get the last error of the InitProvider 
	 * @return the last error that happened in InitProvider
	 */
	public InsiteoError getError() {
		return mError;
	}
	/**
	 * Get path to external storage (ie : sdcard)
	 * @return the path to external storage
	 */
	public String getExternalStoragePath() {
		return mExternalStoragePath;
	}
	/**
	 * Get path to insiteo read-only data directory
	 * @return the path to insiteo RO data directory
	 */
	public String getDataDirPath() {
		return mRODataDirPath;
	}

	/**
	 * Returns the root path of the data directory 
	 * ie RootDirectoryPath + ServerTypePath + siteId
	 */
	public String getDataDirRootPath(){
		String path;
		switch (mServer) {
		case TEST:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "test" + "/" + mSiteId;
			break;
		case DEV:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "dev" + "/" + mSiteId;
			break;
		default:
			path = mExternalStoragePath + "/" + CommonConstants.DATA_DIRECTORY + "/" + "release" + "/" + mSiteId;
			break;
		}
		return path;
	}

	/**
	 * Get path to insiteo read-write data directory
	 * @return the path to insiteo RW data directory
	 */
	public String getRWDataDirPath() {
		return mRWDataDirPath;
	}
	/**
	 * @return the url used to initialize the API
	 */
	public String getInitUrl() {
		return mInitUrl;
	}
	/**
	 * @return the site ID used to initialize the API
	 */
	public int getSiteId() {
		return mSiteId;
	}
	/**
	 * @return the locale used to initialize the API
	 */
	public String getLang() {
		return mLang;
	}
	/**
	 * @return the application code version used to initialize the API
	 */
	public int getAppVersion() {
		return mAppVersion;
	}
	/**
	 * @return the url for lbs requests
	 */
	public String getLbsUrl() {
		return mLbsUrl;
	}
	/**
	 * @return the url for content requests
	 */
	public String getContentUrl() {
		return mContentUrl;
	}
	/**
	 * @return the url for maps requests
	 */
	public String getMapsUrl() {
		return mMapsUrl;
	}

	/**
	 * @return the url for analytics requests
	 */
	public String getAnalyticsUrl() {
		return mAnalyticsUrl;
	}

	/**
	 * Method to get the packages that are required to be updated
	 * @return
	 */
	public Stack&lt;PackageDescriptor&gt; getPackagesToUpdate(){
		return mPackagesToUpdate;
	}
	
	/**
	 * Method to get all the packages available for this site. Should be called after initialization process and if
	 * initialization succeeded.
	 * @return The stack of all the available packages.
	 */
	public Stack&lt;PackageDescriptor&gt; getPackagesAvailable(){
		return mPackagesAvailable;
	}

	/**
	 * Return the current API version.
	 * @return The version of Insiteo's API.
	 */
	public String getAPIVersion(){
		return CommonConstants.API_VERSION;
	}
	
	/**
	 * Returns the last time an API initialization was requested (even if this init failed).
	 * @return mLastInitTime The last initialization time
	 */
	public long getLastInitTime(){
		return mLastInitTime;
	}
	// ==================================================================================================
	// Init async task (cancelable)
	// InitTask will listen PackageUpdater notifications, to be aware of the installation state
	// ==================================================================================================
	private class InitTask implements Runnable, ICancelable, IInitListener {

		private IInitListener mListener;
		private PackageUpdater mPackUpdater = null;
		private volatile boolean mIsCanceled = false;
		private final PackageDescriptor mMasterPackage;
		private final boolean mMasterPackageInAssets;
		private final boolean mForceMasterPackage; 
		private EInitResult mInitRes;

		public InitTask(IInitListener aListener, final PackageDescriptor aMasterPackage, final boolean aMasterPackageInAssets, final boolean aForceMasterPackage) {
			mListener = aListener;
			mMasterPackage = aMasterPackage;
			mMasterPackageInAssets = aMasterPackageInAssets;
			mForceMasterPackage = aForceMasterPackage;
			mInitRes = EInitResult.FAIL;
		}

		@Override
		public void cancel(boolean aKillTask) {
			mIsCanceled = true;
			if (mPackUpdater != null) {
				mPackUpdater.cancel(aKillTask);
			}
			if (mWakeLock.isHeld()) {
				mWakeLock.release();
			}
		}

		@Override
		public void run() {
			try {
				Activity context = mContext.get();
				if (context != null &amp;&amp; !mIsCanceled) {				
					//lock power management (no sleep)
					PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
					mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Insiteo loc service");
					mWakeLock.acquire();

					if (!mIsCanceled) {
						//init sdcard path
						File sdCard = Environment.getExternalStorageDirectory();
						if ((sdCard != null) &amp;&amp; sdCard.canRead()) {
							mExternalStoragePath = sdCard.getCanonicalPath();
						}
						else {
							// no sd card inserted !
							mError = new InsiteoError(InsiteoError.NO_SDCARD_ERROR_CODE, context.getString(R.string.insiteo_common_error_sdcard_access));
							throw new IOException("Unable to access SD card");
						}

						if (!mIsCanceled) {
							//make an init call to the server
							mInitRes = initOnline();

							//if zip exists and was not already loaded, uncompress it on sdcard
							boolean extract = false;
							if (!mIsCanceled &amp;&amp; mMasterPackage != null) {
								//check if zip deployment is forced
								if (mForceMasterPackage) {
									setMasterPackageDeployed(null);
								}
								//extract package if needed
								if (!hasMasterPackage() &amp;&amp; !mIsCanceled) {
									Log.d("Package", "INSTALLING PACKAGE ...");
									extract = true;
									mPackUpdater = new PackageUpdater(context, this);

									closeDBHelpers(false);
									mPackUpdater.deployPackage(mRODataDirPath, mMasterPackage, mMasterPackageInAssets);
								}
							}

							if (!mIsCanceled &amp;&amp; !extract) {

								// Start Analytics API
								initializeAnalytics();

								//no package install running =&gt; notify lister if any
								notifyInitDone(mInitRes);
							}
						}
					}
				}
			}
			catch(Exception e) {
				Log.d("insiteo", "ERROR : cannot init API", e);

				if (!mIsCanceled) {
					//create error message
					String errorMsg = "";
					Activity activity = mContext.get();
					if (activity != null) {
						errorMsg = activity.getString(R.string.insiteo_common_error_unable_to_init_api);
						errorMsg += e.getLocalizedMessage();
					}

					//notify lister if any
					mError = new InsiteoError(InsiteoError.API_NOT_INIT_ERROR_CODE, errorMsg);
					notifyInitDone(EInitResult.FAIL);
				}
			}
		}

		/**
		 * make a call to server for base init, then notify listener with result. 
		 * Also define insiteo data path.
		 */
		private EInitResult initOnline() {
			EInitResult result = EInitResult.FAIL;

			Context context = mContext.get();
			if (context != null &amp;&amp; !mIsCanceled) {
				//create url for init request
				String initUrl = mInitUrl;
				initUrl += CommonConstants.INIT_BASE_SERVICE; 
				initUrl = initUrl.replace(CommonConstants.URLKEY_SITE_ID, ""+mSiteId)
						.replace(CommonConstants.URLKEY_APP_VERS, ""+mAppVersion)
						.replace(CommonConstants.URLKEY_LANG, mLang);

				//load remote data
				BaseInitResponseParser parser = new BaseInitResponseParser();
				if (!mIsCanceled) {
					InsiteoError error = ProtoLoader.load(initUrl, parser);
					mError = error;

					//check init result
					if (InsiteoError.NO_ERROR_CODE.equals(error.getCode())) {
						//data was loaded successfully
						result = EInitResult.SUCCESS;

						//Save returned lang in sharedprefs if it is the default language (ie : if it is different from mLang)
						if (mLang.equalsIgnoreCase(parser.getLang()) == false) {
							setDefaultLanguage(parser.getLang());
							mLang = parser.getLang();	//update lang with the one returned by server
						}						

						mLbsUrl = parser.getLbsUrl();
						mContentUrl = parser.getContentUrl();
						mMapsUrl = parser.getMapsUrl() + mLang + "/";
						mAnalyticsUrl = parser.getAnalyticsUrl();

						//set insiteo data path
						mRODataDirPath = initDataDirPath();
						mRWDataDirPath = initRWDataDirPath();

						if (!mIsCanceled) {
							//check which packages need to be updated
							mPackagesAvailable = parser.getPackages();
							mPackagesToUpdate = filterPackagesToUpdate(mPackagesAvailable);

							if (!mIsCanceled) {							

								if (!mIsCanceled) {
									//check if there is a package to update
									if (mPackagesToUpdate.size() &gt; 0) {
										result = EInitResult.SUCCESS_WITH_NEW_DATA;
									}

									//set init done
									mIsInitialised = true;
								}
							}
						}
					}
					else {
						Log.d("Init", "Error during initBase, with code " + error.getCode());
						//switch to default language if needed
						//set insiteo data path
						mRODataDirPath = initDataDirPath();
						mRWDataDirPath = initRWDataDirPath();
						if (false == new File(mRODataDirPath).isDirectory()) {
							//no package exist for this lang =&gt; try to use default language
							String defLang = getDefaultLanguage();
							if (defLang != null) {
								mLang = defLang;
								mRODataDirPath = initDataDirPath();
							}
						}
					}					
				}
			}

			return result;
		}

		//create the stack of packages that need to be installed
		private Stack&lt;PackageDescriptor&gt; filterPackagesToUpdate(Stack&lt;PackageDescriptor&gt; aPackages) {
			Stack&lt;PackageDescriptor&gt; packagesToUpdate = new Stack&lt;PackageDescriptor&gt;();
			for (PackageDescriptor pd : aPackages) {
				if (!PackageDescriptor.isDeployed(mRODataDirPath, pd.getType(), pd.getVersion())) {
					//the package corresponding to this descriptor is not yet deployed =&gt; add it to the list of packages to update
					packagesToUpdate.push(pd);
				}
			}
			return packagesToUpdate;
		}

		@Override
		public void onInstallProgress(long aCurrentFile, long aTotalFiles) {
			//forward call to InitProvider
			if (mListener != null) {
				mListener.onInstallProgress(aCurrentFile, aTotalFiles);
			}
		}

		@Override
		public void onDataUpdateDone(boolean aSuccess, InsiteoError aError) {
			//init done, and zip install done =&gt; notify listener
			Context context = mContext.get();
			if (context != null &amp;&amp; !mIsCanceled) {
				Log.d("Package", "Install from file " + (aSuccess ? "succeeded" : ("failed : " + aError.getMessage())));

				if (aSuccess) {
					//do another init from server, to update packages status
					mInitRes = initOnline();
				}

				notifyInitDone(mInitRes);
			}
		}

		@Override
		public void onInitDone(EInitResult aResult, InsiteoError aError) {
			//this will never be called
		}

		@Override
		public void onDownloadProgress(long aDownloadedBytes, long aTotalBytes) {
			//forward call to InitProvider
			if (mListener != null) {
				mListener.onDownloadProgress(aDownloadedBytes, aTotalBytes);
			}
		}


		@Override
		public void onPackageDowloadBegin(EPackageType aPkgType) {
			// TODO Auto-generated method stub

		}
	}

	// ==================================================================================================
	// Analytics
	// ==================================================================================================

	private void initializeAnalytics(){
		// Analytics
		if (hasPackage(EPackageType.ANALYTICS)) {
			if (mAnalyticsAutoStart) {
				AnalyticsManager.getInstance().start(mApplicationContext);
			} else {
				//				AnalyticsManager.getInstance().stop();
			}
		} else {
			//			AnalyticsManager.getInstance().stop();
		}
	}
	



}

  </pre>
</div>
<div id="footer">
Generated by <a href="http://code.google.com/p/doclava/">Doclava</a>.
</div> <!-- end footer -->

</div> <!-- jd-content -->

</div><!-- end doc-content -->

</div> <!-- end body-content --> 

<script type="text/javascript">
init(); /* initialize doclava-developer-docs.js */
</script>

</body>
</html>
